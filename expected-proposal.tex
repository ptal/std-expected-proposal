\documentclass[a4paper,10pt]{article}
\usepackage[american]
           {babel} % needed for iso dates
\usepackage{url}
\usepackage{lmodern}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{array}
\usepackage{underscore}
\usepackage{changepage}   % for the adjustwidth environment

\hypersetup{
  hidelinks
}

\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}

\usepackage{color}
\usepackage{textpos}
\usepackage{titling}
\usepackage{titlesec}

\setcounter{secnumdepth}{6}

% From std draft
% We use the 'listings' package, with some small customizations.  The
% most interesting customization: all TeX commands are available
% within comments.  Comments are set in italics, keywords and strings
% don't get special treatment.
% General code style
\lstset{language=C++,
        basicstyle=\small\ttfamily,
        keywordstyle=,
        stringstyle=,
        xleftmargin=1em,
        showstringspaces=false,
        commentstyle=\itshape\rmfamily,
        columns=flexible,
        keepspaces=true,
        texcl=true
}
% end from std draft

\newcommand{\wordingSec}[2]{\vspace{15pt}
\noindent
{\large\textbf{X.Y\quad #1\hfill\textbf{[#2]}}}
}

% Counters
\newcounter{countWordingSubSec}
\newcounter{countWordingSubSubSec}[countWordingSubSec]

\renewcommand{\thecountWordingSubSec}{X.Y.\arabic{countWordingSubSec}}
\renewcommand{\thecountWordingSubSubSec}{X.Y.\arabic{countWordingSubSec}.\arabic{countWordingSubSubSec}}

% Defs of sub and subsub section (for the wording).
\newcommand{\wordingSubSec}[2]{\vspace{15pt}
\refstepcounter{countWordingSubSec}
\noindent
{\textbf{\thecountWordingSubSec\quad #1\hfill\textbf{[#2]}}}
\label{#2}
\vspace{7pt}
}

\newcommand{\wordingSubSubSec}[2]{\vspace{15pt}
\refstepcounter{countWordingSubSubSec}
\noindent
{\textbf{\thecountWordingSubSubSec\quad #1\hfill\textbf{[#2]}}}
\label{#2}
\vspace{7pt}
}

\newcommand{\cpp}[1]{\lstinline{#1}}

% Wording items
\newcommand{\wordingItem}[1]{\noindent\textit{#1:}}

\newenvironment{wordingTextItem}[1]{\wordingItem{#1}\vspace{7pt}\noindent\begin{adjustwidth}{12pt}{}}{\vspace{7pt}\end{adjustwidth}}

\newenvironment{wordingNoteItem}{[\wordingItem{Note}}{---\textit{end note}]}

\newenvironment{wordingPara}{\begin{adjustwidth}{12pt}{}}{\end{adjustwidth}}

\lstset{
  xleftmargin=12pt
}

\setlength{\droptitle}{10em}
\title{A proposal to add a utility class to represent expected objects}
\author{}
\date{}

\begin{document}

\maketitle
\begin{textblock*}{9cm}(7cm,-8cm)
\begin{tabular}{l l}
\textbf{Document number:} & Dxxxx=xx-xxxx \\
\textbf{Date:}  & \today \\
\textbf{Revises:} & None \\
\textbf{Project:} & JTC1.22.32 Programming \\
 & Language C++ \\
\textbf{Reply to:} & Vicente J. Botet Escriba \\
 & <\href{mailto:vicente.botet@wanadoo.fr}{vicente.botet@wanadoo.fr}> \\
 & Pierre Talbot <\href{mailto:ptalbot@hyc.io}{ptalbot@hyc.io}>
\end{tabular}
\end{textblock*}

\vspace{-6em}
\setcounter{tocdepth}{1}
\tableofcontents

\section{Introduction}

Class template \cpp{expected<T,E>} proposed here is a type that may contain a value of type \cpp{T} or a value of type \cpp{E} in its storage space. \cpp{T} represents the expected value, \cpp{E} represents the exceptional reason why it doesn't contains a value of type \cpp{T}. Its interface allows to query if the underlying value is either the expected value (of type \cpp{T}) or an error value (of type \cpp{E}). The original idea comes from Andrei Alexandrescu C++ and Beyond 2012: Systematic Error Handling in C++ talk \cite{AlexandrescuExpected}. The interface is based on \cpp{std::optional} N3793 \cite{OptionalRev5} and Haskell monad either. It requires no changes to core language, and breaks no existing code.

\section{Motivation and Scope}

Basically, the two main error mechanisms are exceptions and return codes. Before further explanation, we should ask us what are the characteristics of a good error mechanism.

\begin{itemize}
 \item \textbf{Error visibility} Failure cases should appears throughout the code review. Because the debug can be painful if the errors are hidden.
 \item \textbf{Information on errors} The errors should carry out as most as possible information from their origin, causes and possibly the ways to resolve it.
 \item \textbf{Clean code} The treatment of errors should be in a separate layer of code and as much invisible as possible. So the code reader could notice the presence of exceptional cases without stop his reading.
 \item \textbf{Non-Intrusive error} The errors should not monopolize a communication channel dedicated to the normal code flow. They must be as discrete as possible. For instance, the return of a function is a channel that should not be exclusively reserved for errors.
\end{itemize}

The first and the third characteristic are quite contradictory. The former points out that errors not handled should appear clearly in the code. The latter tells us that the error handling mustn't interfere with the code reading, meaning that it clearly shows the normal execution flow. A comparison between the exception and return codes is given in the table \ref{comp-handling-error}.


\begin{table}
\bgroup
\def\arraystretch{1.5}
\begin{tabular}{|l|>{\raggedright\arraybackslash}p{5cm}|>{\raggedright\arraybackslash}p{5cm}|}
\hline
                    & \textbf{Exception} & \textbf{Return code} \\
\hline
\textbf{Visibility} & Not visible without further analysis of the code. However, if an exception is thrown, we can follow the stack trace. & Visible at the first sight by watching the prototype of the called function. However ignoring return code can lead to undefined results and it can be hard to figure out the problem. \\
\hline
\textbf{Informations} & Exceptions can be arbitrarily rich. & Historically a simple integer. Nowadays, the header \cpp{<system_error>} provides richer error code. \\
\hline
\textbf{Clean code} & Provides clean code, exceptions can be completely invisible for the caller. & Force you to add, at least, a if statement after each function call. \\
\hline
\textbf{Non-Intrusive} & Proper communication channel. & Monopolization of the return channel. \\
\hline
\end{tabular}
\egroup
\caption{Comparison between two error handling systems.}
\label{comp-handling-error}
\end{table}

\section{Alexandrescu Expected class}

We can do the same analysis for the \cpp{Expected<T>} class from Alexandrescu talk \cite{AlexandrescuExpected}:

\begin{itemize}
 \item \textbf{Error visibility} It takes the best of the exception and error code. It's visible because the return type is Expected<T> and if the user ignore the error case, it throws the contained exception.
 \item \textbf{Information} As rich as exception.
 \item \textbf{Clean code} It's up to the programmer to choose handling errors as error code or to throw the contained exception.
 \item \textbf{Non-Intrusive} Use the return channel without monopolizing it.
\end{itemize}

\noindent
Other characteristics of \cpp{Expected<T>}:

\begin{itemize}
 \item Associates errors with computational goals.
 \item Naturally allows multiple exceptions inflight.
 \item Switch between ``error handling'' and ``exception throwing'' styles.
 \item Teleportation possible.
 \begin{itemize}
  \item Across thread boundaries.
  \item Across nothrow subsystem boundaries.
  \item Across time: save now, throw later.
 \end{itemize}
 \item Collect, group, combine exceptions.
\end{itemize}

\noindent
However \cpp{Expected<T>} class also has some drawbacks:
\begin{itemize}
 \item The error code must be an exception.
 \item It doesn't provide a better solution to resolve errors. You can throw or use the \cpp{hasException<E>()} function to test errors which is similar to the old switch case statement.
 \item The function \cpp{hasException<E>()} test the type and so cannot distinguish two different errors from the same exception. Exception can contains multiple error case scenarios (think about \cpp{std::invalid_argument}).
\end{itemize}

\noindent
The main enhancements or differences of the proposed \cpp{expected<T,E>} respect to \cpp{Expected<T>} are:
\begin{itemize}
 \item \cpp{expected<T,E>} parameterizes the root cause that prevents its creation, \cpp{expected<T,E>} is either a \cpp{T} or the root cause \cpp{E} that prevents its creation. The default type \cpp{E} would be \cpp{std::exception_ptr} as the exceptions seem to be the most used error-handling system. There is also some supports for the classes in the \cpp{<system_error>} header.
 \item \cpp{expected<T,E>} is default constructible.
 \item \cpp{expected<T,E>} is a monad (see [6]).
\end{itemize}


\section{Use cases}

\subsection{Parse int}

\begin{lstlisting}
  expected<int> parseInt(const std::string& s) {
    int result;
    //...
    if (nonDigit)  
      return expected<int>::from_error(std::invalid_argument("not a number"));
    //...
    if (tooManyDigits) 
      return expected<int>::from_error(std::out_of_range("overflow"));
    //...
    return make_expected(result);
  }

  // Caller
  std::string s = readline();
  auto x = parseInt(s).get(); // throw on error
  auto y = parseInt(s); // won't throw
  if (!y.valid()) {
    // handle locally
    if (y.has_exception<std::invalid_argument>()) {
      // no digits
      //...
    }
    y.get(); // just "re"throw the stored exception
  }
\end{lstlisting}

Next follows the parseInt function using a specific error.

\begin{lstlisting}
  expected<int, myerrc> parseInt(const std::string& s)  {
    int result;
    //...
    if (nonDigit)  
      return make_expected_from_error<int>(myerrc::overflow);
    //...
    if (tooManyDigits)  
      return make_expected_from_error<int>(myerrc::overflow);
    //...
    return make_expected(result);
  }

  // Caller
  std::string s = readline();
  auto x = parseInt(s).get(); // throws bad_exected_access(y.error()) on error
  auto y = parseInt(s); // won't throw
  if (!y.valid()) {
    // handle locally
    if (y.error() == std::errc::invalid_argument)  {
      // no digits
      //...
    }
    y.get(); // just throws bad_exected_access(y.error())
  }
\end{lstlisting}

\subsection{Parse int range}

Given a function that parses an int and one that matches a string

\begin{lstlisting}
expected<int> parseInt(iterator&);
expected<void> matchesString(std::string, iterator&);
\end{lstlisting}

how to define a function that parses an int range"<int>..<int>"

\begin{lstlisting}
expected<std::pair<int,int>> parseIntRange(iterator& it);
\end{lstlisting}


Let me start by defining the function as if the functions throw an exception

\begin{lstlisting}
std::pair<int,int> parseIntRange(iterator it) {
    auto f = parseInt(it);
    auto m = matchesString(":", it).
    auto l = parseInt(it);       
    return make_pair(f, l);
}
\end{lstlisting}

One solution consists to check if there is an error at every step. 

\begin{lstlisting}
expected<std::pair<int,int>> parseIntRange(iterator it) {
    auto f = parseInt(it);
    if (! f.valid())  return expected<std::pair<int,int>>::from_exception(f.error());
    auto m = matchesString(":", it).
    if (! m.valid())  return expected<std::pair<int,int>>::from_exception(m.error());
    auto l = parseInt(it);
    if (! l.valid())   return expected<std::pair<int,int>>::from_exception(l.error());
        
    return make_expected(make_pair(f.get(), l.get()));
}
\end{lstlisting}

Another consists in checking if we can continue at each step

\begin{lstlisting}
expected<std::pair<int,int>> parseIntRange(iterator it) {
    auto f = parseInt(it);
    if ( f.valid())  {
        auto m = parse(":", it).
        if (m.valid())  {
            auto l = parseInt(it);
            if (l.valid())  return make_expected(make_pair(f.get(), l.get()));
        }
    }        
    return expected<std::pair<int,int>>::from_exception(l.error());
}
\end{lstlisting}

The preceding approaches contains too much noise respect to the exception based solution. An alternative consists in folding the result and use a continuation passing style. 

\begin{lstlisting}
expected<std::pair<int,int>> parseIntRange(iterator it) {
    return                           parseInt(it). 
    		next([&it](int f) {  fold(f, matchesString("..", it)); }). 
    		next([&it](int f) {  fold(f, parseInt(it)); });
}
\end{lstlisting}

Note that the control flow has disapered but the calls have been wrapped on some esoteric lambda. Let me analyze what is behind the scenes

\begin{lstlisting}
expected<std::pair<int,int>> parseIntRange(iterator it) {
    return parseInt(it). // [1]
    next([&it](int f) { //[2]
        return fold(f, matchesString("..", it)); // [3]
    }). 
    next([&it](int f) { // [4]
        return fold(f, parseInt(it)); // [5]
    });
}
\end{lstlisting}

Line 1: obtains an expected<int> possibly with the parsed int. 
Line 2: the call to next() will return an expect<int> as the lambda returns an expect<int>. This is due to the fact that next unwraps the result so that expect<expect<int>> is unwrapped to expect<int>. 
If it is valid it calls to the lambda and unwraps the result. It it it invalid, it returns an expect<int> with the obtained error.
Line 3: returns an expected that combines first and the success of the call to  matchesString("..", it).
Line4:  the call to next() will return an expect<std::pair<int,int>> as the lambda returns an expect<std::pair<int,int>>. This is due to the fact that next unwraps the result so that expect<expect<std::pair<int,int>>> is unwrapped to expect<std::pair<int,int>>. 
If it is valid it calls to the lambda and unwraps the result. It it is invalid, it returns an expect<std::pair<int,int>> with the obtained error.
Line 5: returns an expected that combines first and the success of the call to  parseInt(it).

Next follows the fold function

\begin{lstlisting}

template<class T, class F>
//requires ! is_void<result_of_t<F()>>::value
expected<std::pair<T, result_of_t<F()>> fold(T first, F f);

template<class T, class F>
//requires is_void<result_of_t<F()>>::value
expected<T> fold(T first, F f) {
\end{lstlisting}

When F() returns expected<void>, the following function will return an expected<T> . It contents depends on the result of the call to f. if the expected result is valid it return an expected with the first argument, otherwise, an expected with the error of the result of the fall to f.  

When F() returns expected<U>, the following function will return an expected<std::pair<T,U>> . It contents depends on the result of the call to f. if the expected result is valid it return an expected with a pair of its first argument and the value of  the result of the call to f , otherwise, an expected with the error of the result of the fall to f.  

This function is useful to store the result of several computations.

\begin{lstlisting}

template<class T, class F>
//requires ! is_void<result_of_t<F()>>::value
expected<std::pair<T, result_of_t<F()>> fold(T first, F f) {
    auto second = f();
    if (second.valid())
        return make_expected(make_pair(first, *second));
    } else  {
        return expected<std::pair<T,int>>::from_exception(second.error());
    }
}
template<class T, class F>
//requires is_void<result_of_t<F()>>::value
expected<T> fold(T first, F f) {
    auto second = f();
    if (second.valid())
        return make_expected(first);
    } else  {
        return expected<std::pair<T,int>>::from_exception(second.error());
    }
}
\end{lstlisting}

Yet another alternative (even if it is not adapted to this example) could be to calculate all the expected and if all are valid return the expected result.

\begin{lstlisting}
expected<std::pair<int,int>> parseIntRange(iterator it) {
    auto f = parseInt(it);
    auto m = parse(":", it).
    auto l = parseInt(it);
    auto all = if_all(f,m,l);
    if (all.valid()) return make_expected(make_pair(all.get()));
    return expected<std::pair<int,int>>::from_exception(all.error());
}
\end{lstlisting}

Let see how the function looks like if it return a tuple.

\begin{lstlisting}
expected<std::tuple<int,int>> parseIntRange(iterator it) {
    auto f = parseInt(it);
    auto m = parse(":", it).
    auto l = parseInt(it);
    return if_all(f, m, l);
}
\end{lstlisting}

Note that this is very close to the exception based solution

\begin{lstlisting}
std::pair<int,int> parseIntRange(iterator it) {
    auto f = parseInt(it);
    auto m = matchesString(":", it).
    auto l = parseInt(it);       
    return make_pair(f, l);
}
\end{lstlisting}


\subsection{xxx}
We should wonder what every programmers do when a function call returns an error:

\begin{enumerate}
 \item Nothing.
 \item Delegate the responsibility of error handling to higher layer.
 \item Trying to resolve the error.
\end{enumerate}

Because the first behavior leads to buggy application, we won't consider it in a first time. Consider the following ``pseudo coded'' mock function:

\begin{lstlisting}
EXPECTED int mock_connect(const string& hostname, const string& passwd, bool timed_out){
  if(passwd != "passwd")
      return connection refused ERROR
  else if(hostname != "localhost")
      return host unreachable ERROR
  else if(timed_out)
      return timed out ERROR
  return HANDLE 0
}
\end{lstlisting}

We imagine a scenario where:

\begin{itemize}
 \item The \textit{connection refused} error is resolved by asking the user another password.
 \item The \textit{host unreachable} error is delegated to the upper layer.
 \item The \textit{time out} error is resolved at the next try.
\end{itemize}

\subsection{Exception-based expected}

The code of the mock connect function is below. You can see that the errors are encapsulated into exceptions.
\begin{lstlisting}
expected<int> mock_connect(
    const std::string& hostname, 
    const std::string& passwd, 
    bool timed_out) {
  if(passwd != "passwd")
      return expected<int>::from_exception(connection_refused());
  else if(hostname != "localhost")
      return expected<int>::from_exception(host_unreachable());
  else if(timed_out)
      return expected<int>::from_exception(timeout());
  return expected<int>(0);
}
\end{lstlisting}

From the caller, the code looks like:

\begin{lstlisting}
expected<int> connect_to_host(const std::string& host){
  return mock_connect(host, ask_password(host), true)
  .recover([](exception_ptr except){
    bool timed_out = true;
    expected<int> handle;
    do { 
      try {  
        if (!valid) std::rethrow_exception(except);
      } catch (const connection_refused& ex) {
        std::cout << "Wrong password ?" << std::endl;
        handle = mock_connect(host, ask_password(host), timed_out);
      } catch (const timeout& ex) {
        std::cout << "Error: timed out. Try again." << std::endl;
        timed_out = false;
        handle = mock_connect(host, ask_password(host), timed_out);
      } catch (...) {
        // Delegate responsibility to higher layer.
        return make_expected<int>(except);      
      }
    } while(!handle.valid());
    return handle;
  }).then([](int value){
    std::cout << "handle no: " << value << std::endl;
  });
}
\end{lstlisting}

Note the error resolver function to keep the code as clean as possible.

\begin{lstlisting}
TODO INSERT CODE
\end{lstlisting}

The next section shows how to do the same things with the standard error code (\cpp{std::error_condition}).

\subsection{Error-based expected}

We use the class \cpp{expected_or_error} which looks like the class expected without the exception.

\begin{lstlisting}
TODO INSERT CODE
\end{lstlisting}

From the caller, the code looks like:

\begin{lstlisting}
TODO INSERT CODE
\end{lstlisting}

And finally the error resolver:

\begin{lstlisting}
TODO INSERT CODE
\end{lstlisting}

We can see that the code is quite similar between both classes. It's mainly because we didn't use the exception facility of the expected class.

\subsection{Result}

The result of the both codes is the same 

\begin{lstlisting}
TODO INSERT CODE
\end{lstlisting}

\section{Impacts on the Standard}

These changes are entirely based on library extensions and do not require any language features beyond what is available in C++ 14. It requires however the \cpp{in_place_t} from N3793.

\section{Design rationale}


\subsection{Never-empty guaranty}
As \cpp{boost::variant}, \cpp{expected<T,E>} ensures that it is never empty.
All instances \cpp{v} of type \cpp{expected<T,E>} guarantee that \cpp{v} has constructed content of one of the types \cpp{T} or \cpp{E}, even if an operation on \cpp{v} has previously failed.

This implies that expected may be viewed precisely as a union of exactly its bounded types. This "never-empty" property insulates the user from the possibility of undefined expected content and the significant additional complexity-of-use attendant with such a possibility.

\subsection{\cpp{expected<T, E>} is default constructible if \cpp{T} is default constructible}

\cpp{expected<T,E>} should behave as much as possible as \cpp{T}. 

\subsection{Making \cpp{expected<T,E>} default constructible}
It is possible to make it default constructible adding an additional \cpp{init} \cpp{bool} member, but this is in some way equivalent to have \cpp{optional<expected<T,E>>}, so this proposal doesn't propose default constructor for any \cpp{T}.

\subsection{Observers}

\subsection{Which exception throw when when the user try to get the expected value but there is none?}

It has been suggested to let the user decide the Exception, that would be throw when the user try to get the expected value but there is none, as third parameter. 

While there is no major complexity doing it, as it just needs a third parameter that could default to the appropriated class, 

\begin{lstlisting}
template <class T, class Error, class Exception = bad_expected_access>
  struct expected;
\end{lstlisting}

the authors consider that this is not really needed and that this parameter should not really be part of the type.

The user can define

\begin{lstlisting}
template <class Exception, class T, class ErrorCode >
  T GetOrThrow(expected<T,ErrorCode>&& v) {
  if (e.valid()) return v.value();
  else throw Exception(v.error());
}
\end{lstlisting}

and use it as

\begin{lstlisting}
std::expected<int, std::error_code> f();
std::expected<int, std::error_code> expect = f();
auto i = GetOrThrow<std::system_error>(expct);  
\end{lstlisting}

This function could be added to the standard, but this proposal doesn't request it. 

The user can also wrap the proposed class in its own expected class

\begin{lstlisting}
template <class T, class Error=std::error_code, class Exception=std::system_error>
struct MyExpected {
  expected <T,E> v;
  MyExpected(expected <T,E> v) : v(v) {}
  T get() {  
    if (e.valid()) return v.value();
    else throw Exception(v.error());
  }
  ...
};
\end{lstlisting}

and use it as

\begin{lstlisting}
std::expected<int, std::error_code> f();
MyExpected<int> expect = f();
auto i = expct.get();  // std::system_error throw if not valid
\end{lstlisting}

A class like this one could be added to the standard, but this proposal doesn't request it. 

\subsection{About expected<T, ErrorCode, Exception>}

It has been suggested also to extend the design into something that contains 

\begin{itemize}
\item a T, or
\item an exception_ptr, or 
\item an error_code
\end{itemize}

Again there is no major difficulty to implement it, but instead of having one variation point we have two, that is is there a value, and if not, if is there an exception_ptr. While this would need only an extra test on the exceptional case, the authors think that it is not worth doing it as all the copy/move/swap operations would be less efficient.  

\begin{lstlisting}
template <class T, class ErrorCode = none, class Exception = expected_default_exception<ErrorCode>>
  struct expected;
\end{lstlisting}



\section{Related work}

\subsection{Either monad and Variant}

\cpp{expected<T,E>} can be seen as a specialization of a possible \cpp{either<T,E>} or \cpp{boost::variant<T,E>} which gives a specific intent to its first parameter, that is, it represent the type of the expected contained value. This specificity allows to provide a pointer like interface, as it is the case for \cpp{std::experimental::optional<T>}. Even if the standard contained a class \cpp{either<T,E>} or \cpp{variant<T,E>}, the interface provided by expected<T,E> is more specific and closer to what the user could expect as the result type of a function. In addition, \cpp{expected<T,E>} doesn't intend to be used to define recursive data as \cpp{boost::variant<>} does.

\subsection{Optional}

We can see \cpp{expected<T,E>} as an optional that collapse all the values of \cpp{E} to \cpp{nullopt}. We can convert an \cpp{expected<T, E>} to an \cpp{optional<T>} with the possible loss of information.

\begin{lstlisting}
template <class T>
optional<T> optionalCast(expected<T,E> v) {
  if (v.valid()) return make_optional(*v);
  else nullopt;
}
\end{lstlisting}

We can convert an \cpp{optional<T>} to an \cpp{expected<T>} with the possible loss of the root cause.

\begin{lstlisting}
template <class T>
expected<T> expectedCast(optional<T>) {
  if (v.valid()) return make_expected(*v);
  else expected<T>::from_exception();
}
\end{lstlisting}

\subsection{Promise and Future}

We can see \cpp{expected<T>} as an immediate \cpp{future<T>}.
While \cpp{promise<>}/\cpp{future<>} focuses on inter-thread asynchronous communication, \cpp{excepted<>} focus on eager and synchronous computations.
We can move a ready \cpp{future<T>} to an \cpp{expected<T>} with no loss of information. At the end, the underlying type of \cpp{future<T>} could be \cpp{shared_ptr<expected<T>>}.

\begin{lstlisting}
template <class T>
expected<T> expectedCast(future<T>&& f) {
  assert (f.ready() && "future not ready");
  if (f.has_exception()) 
    return expected<T>::from_exception(getExceptionPtr(f)); // (1)
  else 
    return make_expected(f.get());
}
\end{lstlisting}

Remark: in line (1) we could use instead \cpp{std::future<T>::get_exception_ptr()}, which is now provided by Boost.Thread, that can be implemented by the library more efficiently than the user could do.

We can combine them as follows

\begin{lstlisting}
fut.then([](future<int> f) { return expectedCast(f).
	then([](i){ ... }).recover(...);}
\end{lstlisting}

We can create also a \cpp{future<T>} from an \cpp{expected<T>}.

\begin{lstlisting}
template <class T>
future<T> make_ready_future(expected<T>&& e) {
  if (e.valid()) 
    return make_ready_future(e.get();
  else 
    return make_exceptional_future(f.error()); // (2)
}
\end{lstlisting}

Remark: line (2) uses Boost.Thread provides

\begin{lstlisting}
future<T> make_exceptional_future(exception_ptr ex);
\end{lstlisting}


\subsection{Expected monad}

As for the \cpp{future<T>} proposal, \cpp{expected<T,E>} provides also a way to visit the stored values.
\cpp{future<T>} provides a \cpp{then()} function that accepts a continuation having the \cpp{future<T>} as parameter. The synchronous nature of expected makes it more appropriated to use two functions, one to manage with the case expected has a value and one to try to recover otherwise. This is more in line with the monad interface, as any function having a \cpp{T} as parameter can be used as parameter of the apply function, no need to have a \cpp{expected<T>}. This make it easier to reuse functions. 

\begin{itemize}
 \item \cpp{expected<T,E>::apply()}/\cpp{expected<T,E>::recover()} are the counterpart of \cpp{future<T>.then()}
 \item \cpp{expected<T,E>::unwrap()} is the counterpart of \cpp{future<T>.unwrap()}
 \item \cpp{expected<T,E>::has_value()} is the counterpart of \cpp{future<T>.has_value()}
 \item \cpp{expected<T,E>::has_exception()} is the counterpart of \cpp{future<T>.has_exception()}
 \item \cpp{expected<T,E>::if_all()} and \cpp{expected<T,E>::if_any()} are the counterpart of \cpp{when_all()} and \cpp{when_any()}
\end{itemize}

\section{Proposed Wording}

The proposed changes have been modified to be expressed as edits to N3797, the C++ Draft Standard \cite{Cppdraft}. The wording has been adapted from N3797 \cite{OptionalRev5}.
\newline

Insert a new paragraph.

\wordingSec{Expected library}{expected}

\wordingSubSec{In general}{expected.general}

This subclause describes class template expected that represents expected objects. An expected object for object type T is an object that contains the storage for another object and manages the lifetime of this contained object T, alternatively it could contain the storage for another exceptional object E. The contained object may not be initialized after the expected object has been initialized, and may not be destroyed before the expected object has been destroyed. The initialization state of the contained object is tracked by the expected object.

\wordingSubSec{Header <experimental/expected> synopsis}{expected.synop}

\begin{lstlisting}
namespace std {namespace experimental {

  // \ref{expected.object}, expected for object types  
  template <class T, class E = exception_ptr>
  class expected;
  template <class E>
  class expected<void, E>;
  
  // \ref{expected.exceptional}, exceptional construction
  struct exceptional_t{};
  constexpr exceptional_t exceptional{};
  
  // \ref{expected.unitialized}, class expected_unitialized 
  class expected_unitialized;
  
  // \ref{expected.bad_expected_access}, class bad_expected_access
  class bad_expected_access;
  
  // \ref{expected.relational_op}, Relational operators
  template <class T>
    constexpr bool operator==(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator!=(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator<(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator>(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator<=(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator>=(const expected<T, E>&, const expected<T, E>&);
    
  // \ref{expected.comparison_T}, Comparison with T
  template <class T> constexpr bool operator==(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator==(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator!=(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator!=(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator<(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator<(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator<=(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator<=(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator>(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator>(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator>=(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator>=(const T&, const expected<T, E>&);

  // \ref{expected.specalg}, Specialized algorithms
  template <class T> 
    void swap(expected<T, E>&, expected<T, E>&) noexcept(see below);

  // \ref{expected.factories}, Factories
  template <class T>
    constexpr expected<typename decay<T>::type> make_expected(T&& v); 
  template <class T> constexpr expected<see below> make_expected(T&&);
  template <> constexpr expected<void> make_expected(); 
  template <class T>
   constexpr expected<T> make_expected_from_exception(std::exception_ptr v); 
  template <class T, class E>
   constexpr expected<T> make_expected_from_exception(E&& v);
  template <class T>
   constexpr expected<T> make_expected_from_exception(); 
  template <class F>
   constexpr typename expected<typename result_type<F>::type
   make_expected_from_call(F f);

  // \ref{expected.hash}, hash support
  template <class T> struct hash;
  template <class T> struct hash<expected<T, E>>;
}}
\end{lstlisting}

\wordingSubSec{Definitions}{expected.defs}

An instance of \cpp{expected<T,E>} is said to be valued if it contains an object of type \cpp{T}.
An instance of \cpp{expected<T,E>} is said to be exceptional if it contains an object of type \cpp{E}.

\wordingSubSec{expected for object types}{expected.object}

\begin{lstlisting}
namespace std {
namespace experimental {

  template <class T, class E>
  class expected
  {
  public:
    typedef T value_type;
    typedef E exceptional_type;
    
     // \ref{expected.object.ctor}, constructors
    constexpr expected() noexcept;
    //constexpr expected() = delete;
    expected(const expected&);
    expected(expected&&) noexcept(see below);
    constexpr expected(const T&);
    constexpr expected(T&&);
    template <class... Args> 
      constexpr explicit expected(in_place_t, Args&&...);
    template <class U, class... Args>
      constexpr explicit expected(in_place_t, initializer_list<U>, Args&&...);
    constexpr expected(exceptional_t, const E&);
    constexpr expected(exceptional_t, E&&);
    template <class... Args> 
      constexpr explicit expected(exceptional_t, in_place_t, Args&&...);
    template <class U, class... Args>
      constexpr explicit expected(exceptional_t, in_place_t,
                                  initializer_list<U>, Args&&...);

    // \ref{expected.object.dtor}, destructor
    ~expected();

    // \ref{expected.object.assign}, assignment
    expected& operator=(const expected&);
    expected& operator=(expected&&) noexcept(see below);
    template <class U> expected& operator=(U&&);
    template <class... Args> void emplace(Args&&...);
    template <class U, class... Args>
      void emplace(initializer_list<U>, Args&&...);

    // \ref{expected.object.swap}, swap
    void swap(expected&) noexcept(see below);

    // \ref{expected.object.observe}, observers
    constexpr T const* operator ->() const;
    T* operator ->();
    constexpr T const& operator *() const;
    T& operator *();
    constexpr explicit operator bool() const noexcept;
    constexpr T const& value() const;
    T& value();
    constexpr E const& error() const;
    E& error();
    template <class U> constexpr T value_or(U&&) const&;
    template <class U> T value_or(U&&) &&;

  private:
    bool valued; // exposition only
    T*   val;    // exposition only
    T*   error;  // exposition only
  };

} // namespace experimental
} // namespace std
\end{lstlisting}


Valued instances of \cpp{expected<T, E>} where T is of object type shall contain a value of type \cpp{T} within its own storage. This value is referred to as the contained value of the expected object. Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained value. The contained value shall be allocated in a region of the \cpp{expected<T, E>} storage suitably aligned for the type T.
\newline

Members valued, val and except are provided for exposition only. Implementations need not provide those members. valued indicates whether the expected object's contained value has been initialized (and not yet destroyed); when valued is true val point to the contained value, and when it is false expect point to the exceptional value. \cpp{T} shall be an object type and shall satisfy the requirements of \cpp{Destructible} (Table 24).

\wordingSubSubSec{Constructors}{expected.object.ctor}

% Copy Constructor
\begin{lstlisting}[xleftmargin=0pt]
expected<T, E>::expected(const expected<T, E>& rhs);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires} \cpp{is_copy_constructible<T>::value == true} and\\
\cpp{is_copy_constructible<E>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Effects}
If \cpp{rhs} is valued initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{*rhs}.\\

\noindent
If \cpp{rhs} is exceptional initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{rhs.error()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T} or \cpp{E}.
\end{wordingTextItem}
\end{wordingPara}

% Move Constructor
\begin{lstlisting}[xleftmargin=0pt]
expected<T, E>::expected(expected<T, E> && rhs) noexcept(/*see below*/);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{is_move_constructible<T>::value == true} and \\
\cpp{is_move_constructible<T>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Effects}
If \cpp{rhs} is valued initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{std::move(*rhs)}. \cpp{bool(rhs)} is unchanged.\\

\noindent
If \cpp{rhs} is exceptional initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{std::move(rhs.error())}. \cpp{bool(rhs)} is unchanged.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T} or \cpp{E}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to:\\
\cpp{is_nothrow_move_constructible<T>::value && is_nothrow_move_constructible<E>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Value Constructor
\begin{lstlisting}[xleftmargin=0pt]
constexpr expected<T, E>::expected(const T& v);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{is_copy_constructible<T>::value == true} and\\
\cpp{is_copy_constructible<E>::value == true}
\end{wordingTextItem}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{v}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{T}'s selected constructor is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\end{wordingPara}

% Move value constructor
\begin{lstlisting}[xleftmargin=0pt]
constexpr expected<T, E>::expected(T&& v); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{is_move_constructible<T>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{std::move(v)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{T}'s selected constructor is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\end{wordingPara}

% Emplace constructor
\begin{lstlisting}[xleftmargin=0pt]
template <class... Args>
constexpr explicit expected(in_place_t, Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{is_constructible<T, Args&&...>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the arguments \cpp{std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{T}'s constructor selected for the initialization is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\end{wordingPara}

% Emplace constructor with initializer list.
\begin{lstlisting}[xleftmargin=0pt]
template <class U, class... Args>
constexpr explicit expected(in_place_t, initializer_list<U> il, Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{is_constructible<T, initializer_list<U>&, Args&&...>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the arguments \cpp{il, std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless:\\
\noindent
\cpp{is_constructible<T, initializer_list<U>&, Args&&...>::value == true}.\\

\noindent
If \cpp{T}'s constructor selected for the initialization is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Destructor}{expected.object.dtor}

\begin{lstlisting}[xleftmargin=0pt]
expected<T, E>::~expected();
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{is_trivially_destructible<T>::value != true} and \cpp{*this} is valued, calls \cpp{val->T::~T()}.\\
If \cpp{is_trivially_destructible<E>::value != true} and \cpp{*this} is exceptional, calls \cpp{error->E::~E()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{is_trivially_destructible<T>::value == true} and \cpp{is_trivially_destructible<E>::value == true} then this destructor shall be a trivial destructor.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Assignment}{expected.object.assign}

% Assignement operator.
\begin{lstlisting}[xleftmargin=0pt]
expected<T, E>& expected<T, E>::operator=(const expected<T, E>& rhs); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{is_copy_constructible<T>::value == true} and\\
\cpp{is_copy_assignable<T>::value == true} and\\
\cpp{is_copy_constructible<E>::value == true} and\\
\cpp{is_copy_assignable<E>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Effects}
if \cpp{*this} is valued and \cpp{rhs} is values, assigns \cpp{*rhs} to the contained value \cpp{val}, otherwise \\
if \cpp{*this} is valued and \cpp{rhs} is exceptional, destroys the contained value by calling \cpp{val->T::~T()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}, otherwise \\
if \cpp{*this} is exceptional and \cpp{rhs} is exceptional, assigns \cpp{rhs.error()} to the contained value \cpp{error}, otherwise \\
if \cpp{*this} is exceptional and \cpp{rhs} is valued, destroys the contained value by calling \cpp{error->E::~E()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, the values of \cpp{valued} and \cpp{rhs.valued} remain unchanged. If an exception is thrown during the call to \cpp{T}'s copy constructor, no effect. If an exception is thrown during the call to \cpp{T}'s copy assignment, the state of its contained value is as defined by the exception safety guarantee of \cpp{T}'s copy assignment. If an exception is thrown during the call to \cpp{E}'s copy constructor, no effect. If an exception is thrown during the call to \cpp{E}'s copy assignment, the state of its contained value is as defined by the exception safety guarantee of \cpp{E}'s copy assignment.
\end{wordingTextItem}
\end{wordingPara}

% Move assignement operator.
\begin{lstlisting}[xleftmargin=0pt]
expected<T, E>& expected<T, E>::operator=(expected<T, E>&& rhs) noexcept(/*see below*/); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{is_move_constructible<T>::value == true} and \\
\cpp{is_move_assignable<T>::value == true} and \\
\cpp{is_move_constructible<E>::value == true} and
\cpp{is_move_assignable<E>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Effects}
if \cpp{*this} is valued and \cpp{rhs} is values, assigns \cpp{std::move(*rhs)} to the contained value \cpp{val}, otherwise \\
if \cpp{*this} is valued and \cpp{rhs} is exceptional, destroys the contained value by calling \cpp{val->T::~T()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}, otherwise \\
if \cpp{*this} is exceptional and \cpp{rhs} is exceptional, assigns \cpp{std::move(rhs.error())} to the contained value \cpp{error}, otherwise  
if \cpp{*this} is exceptional and \cpp{rhs} is valued, destroys the contained value by calling \cpp{error->E::~E()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to:\\
\cpp{is_nothrow_move_assignable<T>::value &&}\\
\cpp{is_nothrow_move_constructible<T>::value &&}\\
\cpp{is_nothrow_move_assignable<E>::value &&}\\
\cpp{is_nothrow_move_constructible<E>::value}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, the values of \cpp{valued} and \cpp{rhs.valued} remain unchanged. If an exception is thrown during the call to \cpp{T}'s move constructor, the state of \cpp{*rhs.val} is determined by exception safety guarantee of \cpp{T}'s move constructor. If an exception is thrown during the call to \cpp{T}'s move assignment, the state of \cpp{*val} and \cpp{*rhs.val} is determined by exception safety guarantee of \cpp{T}'s move assignment. If an exception is thrown during the call to \cpp{E}'s move constructor, the state of \cpp{*rhs.error} is determined by exception safety guarantee of \cpp{E}'s move constructor. If an exception is thrown during the call to \cpp{E}'s move assignment, the state of \cpp{*error} and \cpp{*rhs.error} is determined by exception safety guarantee of \cpp{E}'s move assignment.
\end{wordingTextItem}
\end{wordingPara}

% Value assignement operator.
\begin{lstlisting}[xleftmargin=0pt]
template <class U>
expected<T, E>& expected<T, E>::operator=(U&& v); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{is_constructible<T, U>::value == true} and \\
\cpp{is_assignable<U, TT&, U>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Effects}
If \cpp{*this} is valued assigns \cpp{std::forward<U>(v)} to the contained value; otherwise destroys the contained value by calling \cpp{error->E::~E()} and initializes the contained value as if direct-non-list-initializing object of type \cpp{T} with \cpp{std::forward<U>(v)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, value of valued remains unchanged. If an exception is thrown during the call to \cpp{T}'s constructor, the state of \cpp{v} is determined by exception safety guarantee of \cpp{T}'s constructor. If an exception is thrown during the call to \cpp{T}'s assignment, the state of \cpp{*val} and \cpp{v} is determined by exception safety guarantee of \cpp{T}'s assignment.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless:\\
\cpp{is_same<typename decay<U>::type, T>::value == true}.
\end{wordingTextItem}
\begin{wordingNoteItem}
The reason to provide such generic assignment and then constraining it so that effectively \cpp{T == U} is to guarantee that assignment of the form \cpp{o = \{\}} is unambiguous.
\end{wordingNoteItem}
\end{wordingPara}

% Emplace assignement.
\begin{lstlisting}[xleftmargin=0pt]
template <class... Args>
void expected<T, E>::emplace(Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{is_constructible<T, Args&&...>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Effects}if \cpp{*this} is valued, assigns the contained value \cpp{val} as if constructing an object of type \cpp{T} with the arguments \cpp{std::forward<Args>(args)...}, otherwise \\
destroys the contained value by calling \cpp{error->E::~E()} and  initializes the contained value as if constructing an object of type \cpp{T} with the arguments \cpp{std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If an exception is thrown during the call to \cpp{T}'s constructor, \cpp{*this} is disengaged, and the previous \cpp{*val} (if any) has been destroyed.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\end{wordingPara}

% Emplace with initializer list assignement.
\begin{lstlisting}[xleftmargin=0pt]
template <class U, class... Args>
void expected<T, E>::emplace(initializer_list<U> il, Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{is_constructible<T, initializer_list<U>&, Args&&...>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Effects}
if \cpp{*this} is valued, assigns the contained value \cpp{val} as if constructing an object of type \cpp{T} with the arguments \cpp{il,std::forward<Args>(args)...}, otherwise \\
destroys the contained value by calling \cpp{error->E::~E()} and  initializes the contained value as if constructing an object of type \cpp{T} with the arguments \cpp{il,std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If an exception is thrown during the call to \cpp{T}'s constructor, \cpp{*this} is disengaged, and the previous \cpp{*val} (if any) has been destroyed.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_constructible<T, initializer_list<U>&, Args&&...>::value == true}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Swap}{expected.object.swap}

% swap operation.
\begin{lstlisting}[xleftmargin=0pt]
void expected<T, E>::swap(expected<T, E>& rhs) noexcept(/*see below*/); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
LValues of type \cpp{T} shall be swappable, \cpp{is_move_constructible<T>::value == true}, LValues of type \cpp{E} shall be swappable and \cpp{is_move_constructible<T>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Effects}
if \cpp{*this} is valued and \cpp{rhs} is exceptional, initializes the contained value of \cpp{rhs} by direct-initialization with \cpp{std::move(*(*this))}, followed by \cpp{val->T::~T()}, \cpp{swap(init, rhs.init)}, otherwise \\
if \cpp{*this} is disengaged and \cpp{rhs} is engaged, initializes the contained value of \cpp{*this} by direct-initialization with \cpp{std::move(*rhs)}, followed by \cpp{rhs.val->T::~T()}, \cpp{swap(init, rhs.init)}, otherwise \\
if both \cpp{*this} and \cpp{rhs} are engaged) calls \cpp{swap(*(*this), *rhs)}. 
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, values of \cpp{init} and \cpp{rhs.init} remain unchanged. If an exception is thrown during the call to function swap the state of \cpp{*val} and \cpp{*rhs.val} is determined by the exception safety guarantee of swap for lvalues of \cpp{T}. If an exception is thrown during the call to \cpp{T}'s move constructor, the state of \cpp{*val} and \cpp{*rhs.val} is determined by the exception safety guarantee of \cpp{T}'s move constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exceptions that the expressions in the Effects clause throw.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to: \\
\cpp{is_nothrow_move_constructible<T>::value && noexcept(swap(declval<T&>(), declval<T&>())) &&} \\
\cpp{is_nothrow_move_constructible<E>::value && noexcept(swap(declval<E&>(), declval<E&>()))}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Observers}{expected.object.observe}

% -> operator.
\begin{lstlisting}[xleftmargin=0pt]
constexpr T const* expected<T, E>::operator->() const;
T* expected<T, E>::operator->(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{val}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
Unless \cpp{T} is a user-defined type with overloaded unary operator\&, the first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% * operator.
\begin{lstlisting}[xleftmargin=0pt]
constexpr T const& expected<T, E>::operator*() const;
T& expected<T, E>::operator*(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*val}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% bool convertion operator.
\begin{lstlisting}[xleftmargin=0pt]
constexpr explicit expected<T, E>::operator bool() noexcept; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{valued}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% value accessor.
\begin{lstlisting}[xleftmargin=0pt]
constexpr T const& expected<T, E>::value() const;
T& expected<T, E>::value(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{*val}, \cpp{if bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
\cpp{bad_expected_access if !*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% value_or method.
\begin{lstlisting}[xleftmargin=0pt]
template <class U>
constexpr T expected<T, E>::value_or(U&& v) const&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{is_copy_constructible<T>::value == true} and \\
\cpp{is_convertible<U&&, T>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{bool(*this) ? **this : static_cast<T>(std::forward<U>(v))}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If \cpp{init == true} and exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{init} and \cpp{v} remains unchanged and the state of \cpp{*val} is determined by the exception safety guarantee of the selected constructor of \cpp{T}. Otherwise, when exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{*this} remains unchanged and the state of \cpp{v} is determined by the exception safety guarantee of the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If both constructors of \cpp{T} which could be selected are \cpp{constexpr} constructors, this function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% move value_or.
\begin{lstlisting}[xleftmargin=0pt]
template <class U>
T expected<T, E>::value_or(U&& v) &&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{is_move_constructible<T>::value == true} and \\
\cpp{is_convertible<U&&, T>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{bool(*this) ? std::move(**this) : static_cast<T>(std::forward<U>(v))}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If \cpp{init == true} and exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{init} and \cpp{v} remains unchanged and the state of \cpp{*val} is determined by the exception safety guarantee of the \cpp{T}'s constructor. Otherwise, when exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{*this} remains unchanged and the state of \cpp{v} is determined by the exception safety guarantee of the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Exceptional construction}{expected.exceptional}

\begin{lstlisting}
struct exceptional_t{}; 
constexpr exceptional_t exceptional{};
\end{lstlisting}
\noindent
The \cpp{struct exceptional_t} is an empty structure type used as a unique type to disambiguate constructor and function overloading. Specifically, \cpp{expected<T, E>} has a constructor with \cpp{exceptional_t} as the first argument followed by an E; this indicates that \cpp{expected<T, E>} should be constructed as exceptional. 

\wordingSubSec{Class unitialized_expected}{expected.unitialized}

\wordingSubSec{Class bad_expected_access}{expected.bad_expected_access}

\begin{lstlisting}
namespace std {
  class bad_expected_access : public logic_error {
  public:
    explicit bad_expected_access(const string& what_arg);
    explicit bad_expected_access(const char* what_arg);
  };
}
\end{lstlisting}
The class \cpp{bad_expected_access} defines the type of objects thrown as exceptions to report the situation where an attempt is made to access the value of a exceptional expected object.

% constructor with string message.
\begin{lstlisting}[xleftmargin=0pt]
bad_expected_access(const string& what_arg); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Constructs an object of class \cpp{bad_expected_access}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{strcmp(what(), what_arg.c_str()) == 0}.
\end{wordingTextItem}
\end{wordingPara}

% constructor with char* message.
\begin{lstlisting}[xleftmargin=0pt]
bad_expected_access(const char* what_arg); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Constructs an object of class \cpp{bad_expected_access}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{strcmp(what(), what_arg) == 0}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Relational operators}{expected.relational_op}

\wordingSubSec{Comparison with T}{expected.comparison_T}

\wordingSubSec{Specialized algorithms}{expected.specalg}

% swap free function.
\begin{lstlisting}[xleftmargin=0pt]
template <class T, class E>
void swap(expected<T, E>& x, expected<T, E>& y) noexcept(noexcept(x.swap(y))); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
calls \cpp{x.swap(y)}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Factories}{expected.factories}

% make_expected move value factory.
\begin{lstlisting}[xleftmargin=0pt]
template <class T>
constexpr expected<typename decay<T>::type> make_expected(T&& v);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<typename decay<T>::type>(std::forward<T>(v))}.
\end{wordingTextItem}
\end{wordingPara}

% make_expected factory.
\begin{lstlisting}[xleftmargin=0pt]
template <>
constexpr expected<void> make_expected(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<void>(in_place)}.
\end{wordingTextItem}
\end{wordingPara}

% make_expected_from_exception factory.
\begin{lstlisting}[xleftmargin=0pt]
template <class T>
constexpr expected<T> make_expected_from_exception(std::exception_ptr v); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<T>(exceptional, std::forward<E>(v))}.
\end{wordingTextItem}
\end{wordingPara}

% make_expected_from_exception factory.
\begin{lstlisting}[xleftmargin=0pt]
template <class T, class E>
constexpr expected<T> make_expected_from_exception(E&& v);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
Equivalent to:
\begin{lstlisting}
if(typeid(e)!=typeid(E)){
  throw invalid_argument( "slicing detected");
}
return make_expected_from_exception<T>(make_exception_ptr(v));
\end{lstlisting}
\end{wordingTextItem}
\end{wordingPara}


% make_expected_from_exception factory (flying exception).
\begin{lstlisting}[xleftmargin=0pt]
template <class T>
constexpr expected<T> make_expected_from_exception(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{make_expected_from_exception<T>(std::current_exception())}
\end{wordingTextItem}
\end{wordingPara}

% make_expected_from_call
\begin{lstlisting}[xleftmargin=0pt]
template <class F>
constexpr typename expected<result_type<F>::type make_expected_from_call(F f);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Hash support}{expected.hash}

\section{Implementability}
This proposal can be implemented as pure library extension, without any compiler magic support, in C++14. An almost full reference implementation of this proposal can be found at TBoost.Expected \cite{boost.expected}. 
\section{Acknowledgement}

We are very grateful to Andrei Alexandrescu for his talk, which was the origin of this work.
We thanks also to every one that has contributed to the Haskell either monad, as either's interface was a source of inspiration.
Thanks to Fernando Cacciola, Andrzej Krzemieski and every one that has contributed to the wording of N3793 \cite{OptionalRev5}.

\newpage
\bibliographystyle{plain}
\bibliography{references}

\end{document}