\documentclass[a4paper,10pt]{article}
\usepackage[american]
           {babel} % needed for iso dates
\usepackage{url}
\usepackage{lmodern}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{array}
\usepackage{underscore}
\usepackage{changepage}   % for the adjustwidth environment

\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}

\usepackage{color}
\usepackage{textpos}
\usepackage{titling}
\usepackage{titlesec}

\hypersetup{
  hidelinks
}

\setcounter{secnumdepth}{6}

% From std draft
% We use the 'listings' package, with some small customizations.  The
% most interesting customization: all TeX commands are available
% within comments.  Comments are set in italics, keywords and strings
% don't get special treatment.
% General code style
\lstset{language=C++,
        basicstyle=\small\ttfamily,
        keywordstyle=,
        stringstyle=,
        xleftmargin=1em,
        showstringspaces=false,
        commentstyle=\itshape\rmfamily,
        columns=flexible,
        keepspaces=true,
        texcl=true
}
% end from std draft

\newcommand{\wordingSec}[2]{\vspace{15pt}
\noindent
{\large\textbf{X.Y\quad #1\hfill\textbf{[#2]}}}
}

% Counters
\newcounter{countWordingSubSec}
\newcounter{countWordingSubSubSec}[countWordingSubSec]

\renewcommand{\thecountWordingSubSec}{X.Y.\arabic{countWordingSubSec}}
\renewcommand{\thecountWordingSubSubSec}{X.Y.\arabic{countWordingSubSec}.\arabic{countWordingSubSubSec}}

% Defs of sub and subsub section (for the wording).
\newcommand{\wordingSubSec}[2]{\vspace{15pt}
\refstepcounter{countWordingSubSec}
\noindent
{\textbf{\thecountWordingSubSec\quad #1\hfill\textbf{[#2]}}}
\label{#2}
\vspace{7pt}
}

\newcommand{\wordingSubSubSec}[2]{\vspace{15pt}
\refstepcounter{countWordingSubSubSec}
\noindent
{\textbf{\thecountWordingSubSubSec\quad #1\hfill\textbf{[#2]}}}
\label{#2}
\vspace{7pt}
}

\newcommand{\cpp}[1]{\lstinline{#1}}

\newcommand{\todo}[1]{\emph{\textcolor{red}{TODO: #1}}}

% Wording items
\newcommand{\wordingItem}[1]{\noindent\textit{#1:}}

\newenvironment{wordingTextItem}[1]{\wordingItem{#1}\vspace{2pt}\noindent\begin{adjustwidth}{12pt}{}}{\vspace{2pt}\end{adjustwidth}}

\newenvironment{wordingNoteItem}{[\wordingItem{Note}}{---\textit{end note}]}

\newenvironment{wordingPara}{\begin{adjustwidth}{12pt}{}}{\end{adjustwidth}}

\lstset{
  xleftmargin=12pt
}

\setlength{\droptitle}{10em}
\title{A proposal to add a utility class to represent expected monad}
\author{}
\date{}

\begin{document}

\maketitle
\begin{textblock*}{9cm}(7cm,-8cm)
\begin{tabular}{l l}
\textbf{Document number:} & Dxxxx=xx-xxxx \\
\textbf{Date:}  & \today \\
\textbf{Revises:} & None \\
\textbf{Project:} & JTC1.22.32 Programming \\
 & Language C++ \\
\textbf{Reply to:} & Vicente J. Botet Escriba \\
 & <\href{mailto:vicente.botet@wanadoo.fr}{vicente.botet@wanadoo.fr}> \\
 & Pierre Talbot <\href{mailto:ptalbot@hyc.io}{ptalbot@hyc.io}>
\end{tabular}
\end{textblock*}

\vspace{-6em}
\setcounter{tocdepth}{1}
\tableofcontents

\section{Introduction}
%%%%%%%%%%%

Class template \cpp{expected<E,T>} proposed here is a type that may contain a value of type \cpp{T} or a value of type \cpp{E} in its storage space. \cpp{T} represents the expected value, \cpp{E} represents the reason explaining why it doesn't contains a value of type \cpp{T}, that is the unexpected value. Its interface allows to query if the underlying value is either the expected value (of type \cpp{T}) or an unexpected value (of type \cpp{E}). The original idea comes from Andrei Alexandrescu C++ and Beyond 2012: Systematic Error Handling in C++ talk \cite{AlexandrescuExpected}. The interface and the rational are based on \cpp{std::optional} N3793 \cite{OptionalRev5} and Haskell monads. We can consider that \cpp{expected<E,T>} is a generalization of \cpp{optional<T>} providing in addition a monad interface and some specific functions associated to the unexpected type \cpp{E}. It requires no changes to core language, and breaks no existing code.

\section{Motivation and Scope}
\label{motiv-scope}
%%%%%%%%%%%%%%%%

Basically, the two main error mechanisms are exceptions and return codes. Before further explanation, we should ask us what are the characteristics of a good error mechanism.

\begin{itemize}
 \item \textbf{Error visibility} Failure cases should appears throughout the code review. Because the debug can be painful if the errors are hidden.
 \item \textbf{Information on errors} The errors should carry out as most as possible information from their origin, causes and possibly the ways to resolve it.
 \item \textbf{Clean code} The treatment of errors should be in a separate layer of code and as much invisible as possible. So the code reader could notice the presence of exceptional cases without stop his reading.
 \item \textbf{Non-Intrusive error} The errors should not monopolize a communication channel dedicated to the normal code flow. They must be as discrete as possible. For instance, the return of a function is a channel that should not be exclusively reserved for errors.
\end{itemize}

The first and the third characteristic seem to be quite contradictory and deserve further explanation. The former points out that errors not handled should appear clearly in the code. The latter tells us that the error handling mustn't interfere with the code reading, meaning that it clearly shows the normal execution flow. A comparison between the exception and return codes is given in the table \ref{comp-handling-error}.


\begin{table}
\bgroup
\def\arraystretch{1.5}
\begin{tabular}{|l|>{\raggedright\arraybackslash}p{5cm}|>{\raggedright\arraybackslash}p{5cm}|}
\hline
                    & \textbf{Exception} & \textbf{Return code} \\
\hline
\textbf{Visibility} & Not visible without further analysis of the code. However, if an exception is thrown, we can follow the stack trace. & Visible at the first sight by watching the prototype of the called function. However ignoring return code can lead to undefined results and it can be hard to figure out the problem. \\
\hline
\textbf{Informations} & Exceptions can be arbitrarily rich. & Historically a simple integer. Nowadays, the header \cpp{<system_error>} provides richer error code. \\
\hline
\textbf{Clean code} & Provides clean code, exceptions can be completely invisible for the caller. & Force you to add, at least, a if statement after each function call. \\
\hline
\textbf{Non-Intrusive} & Proper communication channel. & Monopolization of the return channel. \\
\hline
\end{tabular}
\egroup
\caption{Comparison between two error handling systems.}
\label{comp-handling-error}
\end{table}

\subsection{Alexandrescu Expected class}
%%%%%%%%%%%%%%%%%%%%

We can do the same analysis for the \cpp{Expected<T>} class from Alexandrescu talk \cite{AlexandrescuExpected}:

\begin{itemize}
 \item \textbf{Error visibility} It takes the best of the exception and error code. It's visible because the return type is Expected<T> and if the user ignore the error case, it throws the contained exception.
 \item \textbf{Information} As rich as exception.
 \item \textbf{Clean code} It's up to the programmer to choose handling errors as error code or to throw the contained exception.
 \item \textbf{Non-Intrusive} Use the return channel without monopolizing it.
\end{itemize}

\noindent
Other characteristics of \cpp{Expected<T>}:

\begin{itemize}
 \item Associates errors with computational goals.
 \item Naturally allows multiple exceptions inflight.
 \item Switch between ``error handling'' and ``exception throwing'' styles.
 \item Teleportation possible.
 \begin{itemize}
  \item Across thread boundaries.
  \item Across nothrow subsystem boundaries.
  \item Across time: save now, throw later.
 \end{itemize}
 \item Collect, group, combine exceptions.
\end{itemize}

\noindent
However \cpp{Expected<T>} class also has some minor limitations:
\begin{itemize}
 \item The error code must be an exception.
 \item It doesn't provide a better solution to resolve errors. You can throw or use the \cpp{hasException<E>()} function to test errors which is similar to the old switch case statement.
 \item The function \cpp{hasException<E>()} test the type and so cannot distinguish two different errors from the same exception. Exception can contains multiple error case scenarios (think about \cpp{std::invalid_argument}).
\end{itemize}

\subsection{Differences between the proposed expected class and Alexandrescu Expected class}

The main enhancements or differences of the proposed \cpp{expected<E,T>} respect to \cpp{Expected<T>} are:
\begin{itemize}
 \item \cpp{expected<E,T>} parameterizes the root cause that prevents its creation, \cpp{expected<E,T>} is either a \cpp{T} or the root cause \cpp{E} that prevents its creation.  \item \cpp{expected<E,T>} is default constructible.
 \item \cpp{expected<E,T>} is implicitly constructible from an \cpp{unexpected_type<E>}.
 \item \cpp{expected<E,T>} is a monad error (see \cite{MONAD_ERROR}).
\end{itemize}

\section{Use cases}
%%%%%%%%%%

\subsection{Safe division}
\label{divide-example}
%%%%%%%%%%%

This first example shows how to define a safe divide operation checking for divide-by-zero conditions. Using exceptions, we might write something like this:

\begin{lstlisting}
struct DivideByZero: public std::exception {...};

int safe_divide(int i, int j)
{
  if (j==0) throw DivideByZero();
  else return i / j;
}
\end{lstlisting}

\noindent
Which, using \cpp{expected<exception_ptr,int>}, turns to:

\begin{lstlisting}
expected<exception_ptr,int> safe_divide(int i, int j) noexcept
{
  if (j==0) return make_unexpected(DivideByZero()); // (1)
  else return i / j; // (2)
}
\end{lstlisting}

(1) The implicit conversion from \cpp{unexpected_type<E>} to \cpp{expected<E,T>} and (2) from \cpp{T} to \cpp{expected<E,T>} prevents using too much boilerplate code. The advantages are that we have a clean way to fail without using the exception machinery, and we can give precise information about why it failed as well. The liability is that this function is going to be tedious to use. For instance, the exception based function:

\begin{lstlisting}
int f1(int i, int j, int k)
{
  return i + safe_divide(j,k);
}
\end{lstlisting}

\noindent
becomes using \texttt{expected<exception_ptr,int>}:

\begin{lstlisting}
expected<exception_ptr,int> f1(int i, int j, int k) noexcept
{
  auto q = safe_divide(j, k)
  if(q.valid()) return i + *q;
  else return q;
}
\end{lstlisting}

\noindent
However \cpp{expected<E,T>} delivers cleaner code when used in a functional style:

\begin{lstlisting}
expected<exception_ptr,int> f1(int i, int j, int k) noexcept
{
  return safe_divide(j, k).next([&](int q){
    return i + q;
  });
}
\end{lstlisting}

The \cpp{next} members calls the continuation provided if expected contains a value, otherwise it forwards the error to the callee. Using lambda function might cluttered the code, so here an example using functor:

\begin{lstlisting}
expected<exception_ptr,int> f1(int i, int j, int k) noexcept
{
  return safe_divide(j, k)
    .next(bind(plus, i, _1));
}
\end{lstlisting}

We can use \cpp{expected<E, T>} to represent different error conditions. For instance, with integer division, we might want to fail if the two numbers are not evenly divisible as well as checking for division by zero. We can improve our \cpp{safe_divide} function accordingly:

\begin{lstlisting}
struct NotDivisible: public std::exception
{
  int i, j;
  NotDivisible(int i, int j) : i(i), j(j) {}
};

expected<exception_ptr,int> safe_divide(int i, int j) noexcept
{
  if (j == 0) return make_unexpected(DivideByZero()); 
  if (i%j != 0) return make_unexpected(NotDivisible(i,j));
  else return i / j; 
}
\end{lstlisting}

Now we have a division function for integers that possibly fail in two ways. However, it's not easy to write code that detect which of the two conditions occurred. For instance, we might have situations where dividing two integers which are not evenly divisible is OK (we just throw away the remainder) but division by zero is probably never going to be OK. Let's try to write this using our safe_divide function, first using exceptions:

\begin{lstlisting}
T divide(T i, T j)
{
  try
  {
    return safe_divide(i,j)
  }
  catch(NotDivisible& ex)
  {
    return ex.i/ex.j;
  }
  catch(...)
  {
    throw;
  }
}
\end{lstlisting}

\noindent
and then using \cpp{expected<E,T>}:

\begin{lstlisting}
expected<exception_ptr,int> divide(int i, int j) noexcept
{
  auto e = safe_divide(i,j);
  if(has_unexpected<NotDivisible>(e))
    return i/j;
  else 
    return e;
}
\end{lstlisting}

\noindent
The \cpp{has_unexpected} function throws the contained exception and thus should not be called multiple times to discriminate over exceptions in an if-else statement if we care about performances. A more efficient way is shown in section \ref{exception-based-expected}. Lets continue with the exception-oriented function $i/k + j/k$:

\begin{lstlisting}
int f2(int i, int j, int k)
{
  return safe_divide(i,k) + safe_divide(j,k);
}
\end{lstlisting}

\noindent
Now let's write this code using an \cpp{expected<E,T>} type and an imperative flavour:

\begin{lstlisting}
expected<exception_ptr,int> f2(int i, int j, int k) noexcept
{
  auto q1 = safe_divide(i, k);
  if (!q1.valid()) return q1;

  auto q2 = safe_divide(j, k);
  if (!q2.valid()) return q2;

  return *q1 + *q2;
}
\end{lstlisting}

This is nice in the sense that whenever there is an error we get a specific error result. However the ``clean code'' characteristic introduced in section \ref{motiv-scope} is not well-respected as the readability doesn't differ much from the ``C return code''. We can rewrite this using a continuation passing style as follows:

\begin{lstlisting}
expected<exception_ptr,int> f(int i, int j, int k) noexcept
{
  return safe_divide(i, k).then([=](int q1) {
      return safe_divide(j,k).then([=](int q2) {
        return q1+q2;
      });
    });
}
\end{lstlisting}

The error-handling code has completely disappeared but the continuations are a new source of noise, and this is even more important with $n$ expected variables. A cleaner solution uses the variadic free function \cpp{mbind}\footnote{\cpp{mbind} stands for ``monadic bind''.}:

\begin{lstlisting}
expected<exception_ptr,int> f(int i, int j, int k)
{
  return mbind(plus,
    safe_divide(i, k), 
    safe_divide(j, k));
}
\end{lstlisting}

The function \cpp{mbind} returns the first erroneous expected argument or, if they all contain a value, the result of the \cpp{plus} operation.

\subsection{Error retrieval and correction}
%%%%%%%%%%%%%%%%

The major advantage of \cpp{expected<E,T>} over \cpp{optional<T>} is the ability to transport un error, but we didn't come yet to an example that retrieve the error. First of all, we should wonder what a programmer do when a function call returns an error:

\begin{enumerate}
 \item Ignore it.
 \item Delegate the responsibility of error handling to higher layer.
 \item Trying to resolve the error.
\end{enumerate}

Because the first behaviour might lead to buggy application, we won't consider it in a first time. The handling is dependent of the underlying error type, we consider the \cpp{exception_ptr} and the \cpp{error_condition} types.

\subsubsection{Exception-based expected}
\label{exception-based-expected}

The following example (previously introduced in section \ref{divide-example}) shows how to transform an expected interface into the corresponding exception one's. It is useful if we want to switch over different error-handling style.

\begin{lstlisting}
int f2(int i, int j, int k)
{
  // if the underlying expected doesn't contain a value
  // it throws the contained exception.
  int q1 = safe_divide(i, k).value();
  int q2 = safe_divide(j, k).value();

  return q1 + q2;
}
\end{lstlisting}

Thus the \cpp{f2} function is no longer annotated with the \cpp{noexcept} specifier. In some cases, even if the underlying error system is exception-based, we don't want to throw it away but to directly recover from the unexpected value. 

\begin{lstlisting}
int divide_or_0(int i, int j) noexcept
{
  auto e = safe_divide(i,j);
  return *(e.catch_error(const exception_ptr& e){
    return 0;
  }));
}
\end{lstlisting}

The \cpp{catch_error} function calls the continuation if the expected is erroneous. In some case, we'll be able to recover only from a subset of the possible error. With exception, the most efficient way is to throw the contained exception and catch the ones we're able to recover from.

\begin{lstlisting}
expected<exception_ptr,int> divide_lower_bound(int i, int j) noexcept
{
  auto e = safe_divide(i,j);
  return e.catch_error(const exception_ptr& e){
    try
    {
      rethrow_exception(e);
    }
    // If it failed because it wasn't an integer division.
    catch(const NotDivisible& d)
    {
      return d.i/d.j;
    }
    catch(...)
    {
      return make_unexpected(e);
    }
  });
}
\end{lstlisting}

Some might argue that this solution is nearly identical to the one with exception-only presented in section \ref{divide-example}. The main advantages are the error treatment isolation (it can be encapsulated in a function) and we keep the basic advantages of expected despite manipulating exception (our function is still \cpp{noexcept}).

\subsubsection{Error-based expected}

The two last examples would work similarly with any other kinds of error. For example here we're using the \cpp{error_condition} type.

\begin{lstlisting}
expected<error_condition, int> divide_lower_bound(int i, int j) noexcept
{
  auto e = safe_divide(i,j);
  return e.catch_error(const error_condition& e){
    if(e.value() == divide_err::not_divisible)
    {
      return d.i/d.j;
    }
    else
    {
      return make_unexpected(e);
    }
  });
}
\end{lstlisting}

The code is similar to the one with exceptions but do not suffer from performance issue since we don't re-throw exceptions.

\section{Impacts on the Standard}
%%%%%%%%%%%%%%%%%

These changes are entirely based on library extensions and do not require any language features beyond what is available in C++ 14. It requires however the \cpp{in_place_t} from N3793.

\section{Design rationale}
%%%%%%%%%%%%%

The same rationale described in \cite{OptionalRev4} for \cpp{optional<T>} applies to \cpp{expected<E,T>} and \cpp{expected< nullopt_t, T>} should behave as \cpp{optional<T>}.  That is, we see \cpp{expected<E,T>} as \cpp{optional<T>} for which all the values of \cpp{E} collapse into a single value \cpp{nullopt}. In the following sections we present the specificities of the rationale in \cite{OptionalRev4} applied to  \cpp{expected<E,T>}.

\subsection{Conceptual model of \cpp{expected<E,T>}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cpp{expected<E,T>} models a discriminated union of types \cpp{T} and \cpp{unexpected_type<E>}. \cpp{expected<E,T>} is viewed as a value of type \cpp{T} or value of type \cpp{unexpected_type<E>}, allocated in the same storage, along with the way of determining which of the two it is. 

The interface in this model requires operations such as comparison to \cpp{T}, comparison to \cpp{E}, assignment and creation from either. It is easy to determine what the value of the expected object is in this model: the type it stores (\cpp{T} or \cpp{E}) and either the value of \cpp{T} or the value of \cpp{E}. 

Additionally, within the affordable limits, we propose the view that \cpp{expected<E,T>} extends the set of the values of \cpp{T} by the values of type \cpp{E}. This is reflected in initialization, assignment, ordering, and equality comparison with both \cpp{T} and \cpp{E}. In the case of  \cpp{optional<T>}, \cpp{T} can not be a \cpp{nullopt_t}. As the types \cpp{T} and \cpp{E} could be the same in \cpp{expected<E,T>}, there is need to tag the values of \cpp{E} to avoid ambiguous expressions. The \cpp{make_unexpected(E)} function is proposed for this purpose. However \cpp{T} can not be  \cpp{unexpected_type<E>} for a given \cpp{E}.

\begin{lstlisting}
expected<string, int> ei = 0;
expected<string, int> ej = 1;
expected<string, int> ek = make_unexpected(string());

ei = 1;
ej = make_unexpected(E());;
ek = 0;

ei = make_unexpected(E());;
ej = 0;
ek = 1;
\end{lstlisting}

\subsection{Initialization of \cpp{expected<E,T>}}
%%%%%%%%%%%%%%%%%%%%%%%

In cases \cpp{T} and \cpp{E} are value semantic types capable of storing \cpp{n} and \cpp{m} distinct values respectively, \cpp{expected<E,T>} can be seen as an extended \cpp{T} capable of storing \cpp{n + m} values: these that \cpp{T} and \cpp{E} stores. Any valid initialization scheme must provide a way to put an expected object to any of these states. In addition, some \cpp{T}'s  are not \cpp{CopyConstructible} and their expected variants still should constructible with any set of arguments that work for \cpp{T}. 

As in \cite{OptionalRev4}, the model retained is to initialize either by providing either an already constructed \cpp{T} or a tagged \cpp{E}.

\begin{lstlisting}
string s{"STR"};

expected<exception_ptr,string> es{s};                    // requires Copyable<T>
expected<exception_ptr,string> et = s;                   // requires Copyable<T>
expected<exception_ptr,string> ev = string{"STR"};       // requires Movable<T>

expected<exception_ptr,string> ew;                       // unexpected value
expected<exception_ptr,string> ex{};                     // unexpected value
expected<exception_ptr,string> ey = {};                  // unexpected value
expected<exception_ptr,string> ez = expected<exception_ptr,string>{};  // unexpected value
\end{lstlisting}

In order to create a unexpected object a special function needs to be used: \cpp{make_unexpected}:

\begin{lstlisting}
expected<int, string> ep{make_unexpected(-1)};              // unexpected value, requires Movable<E>
expected<int, string> eq = {make_unexpected(-1)};           // unexpected value, requires Movable<E>
\end{lstlisting}

As in \cite{OptionalRev4}, and in order to avoid calling move/copy constructor of \cpp{T}, we use a 'tagged' placement constructor: 

\begin{lstlisting}
expected<exception_ptr,MoveOnly> eg;                        // unexpected value
expected<exception_ptr,MoveOnly> eh{};                      // unexpected value
expected<exception_ptr,MoveOnly> ei{in_place};               // calls MoveOnly{} in place
expected<exception_ptr,MoveOnly> ej{in_place, "arg"};        // calls MoveOnly{"arg"} in place
\end{lstlisting}

To avoid calling move/copy constructor of \cpp{E}, we use a 'tagged' placement constructor: 

\begin{lstlisting}
expected<string,int> ei{unexpect};               // unexpected value, calls string{} in place
expected<string,int> ej{unexpect, "arg"};        // unexpected value, calls string{"arg"} in place
\end{lstlisting}

An alternative name for \cpp{in_place} that is coherent with the \cpp{unexpect} could be \cpp{expect}. Been compatible with \cpp{optional<T>} seems more important and in addition, a complementary proposal introduce the \cpp{expect} keyword. So this proposal doesn't propose such a \cpp{expect} tag.

The alternative and also comprehensive initialization approach, which is not compatible with the choice to default construct \cpp{expected<E,T>} to \cpp{E()}, could be to have a variadic perfect forwarding constructor that just forwards any set of arguments to the constructor of the contained object of type \cpp{T}. 
 
\subsection{Never-empty guaranty}
%%%%%%%%%%%%%%%%%%

As \cpp{boost::variant}, \cpp{expected<E,T>} ensures that it is never empty.
All instances \cpp{v} of type \cpp{expected<E,T>} guarantee that \cpp{v} has constructed content of one of the types \cpp{T} or \cpp{E}, even if an operation on \cpp{v} has previously failed.

This implies that expected may be viewed precisely as a union of exactly its bounded types. This "never-empty" property insulates the user from the possibility of undefined expected content and the significant additional complexity-of-use attendant with such a possibility.

\subsubsection{The default constructor}
%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item \cpp{std::experimental::optional<T>} default constructs to an optional with no value. 
\item \cpp{boost::variant<T,E>} default constructs to a variant with the value \cpp{T()} it \cpp{T} is default constructible or to the value \cpp{E()} it \cpp{E} is default constructible or it is ill formed otherwise. 
\item \cpp{std::future<T>} default constructs to an invalid future with no shared state associated, that is, no value and no exception.
\item \cpp{std::experimental::optional<T>} default constructot is equivalent to \cpp{boost::variant<nullopt_t, T>}.
\end{itemize}

\begin{itemize}
\item Should the default constructor of \cpp{std::expected<E,T>} behave like \cpp{boost::variant<T,E>} or as \cpp{boost::variant<E,T>}?
\item Should the default constructor of \cpp{std::expected<E,T>} behave like \cpp{std::experimental::optional<boost::variant<T,E>>}?
\item Should the default constructor of \cpp{std::expected<nullopt_t,T>} behave like \cpp{std::experimental::optional<T>}? If yes, how should behave the default constructor of \cpp{std::expected<E,T>}? as if initialized with \cpp{make_unexpected(E())}? This will be equivalent to the initialization of \cpp{boost::variant<E,T>}.
\item Should \cpp{std::expected<E,T>} provide a default constructor at all? \cite{OptionalRev3} present valid arguments agains this approach, e.g. \cpp{array<optional<T>} would not be possible. 
\end{itemize}

Requiring \cpp{E} to be default constructible seems less constraining than requiring \cpp{T} to be default constructible. E.g. consider the \cpp{Date} example in \cite{OptionalRev3}. With the same semantics \cpp{expected<E,Date>} would be \cpp{Regular} with a meaningful not-a-date state created by default.

There is still a minor issue as the default constructor of \cpp{std::exception_ptr} doesn't contains an exception and so getting the value of a default constructed \cpp{expected<exception_ptr, T>} would need to check if the stored \cpp{std::exception_ptr} is equal to \cpp{std::exception_ptr()} and throw a specific exception.

The authors consider the arguments in  \cite{OptionalRev3} valid and so propose that \cpp{expected<E,T>} default constructor should behave as constructed with \cpp{make_unexpected(E())}.

\subsubsection{Conversion from \cpp{T}}
%%%%%%%%%%%%%%%%%%

An object of type \cpp{T} is convertible to an expected object of type \cpp{expected<E,T>}:

\begin{lstlisting}
expected<exception_ptr,int> ei = 1; // works
\end{lstlisting}

This convenience feature is not strictly necessary because you can achieve the same effect by using tagged forwarding constructor:

\begin{lstlisting}
expected<exception_ptr,int> ei{in_place, 1};
\end{lstlisting}

If the latter appears too inconvenient, one can always use function \cpp{make_expected} described below:

\begin{lstlisting}
expected<exception_ptr,int> ei = make_expected(1); 
auto ej = make_expected(1); 
\end{lstlisting}

\subsubsection{Using \cpp{unexpect} or \cpp{make_unexpected} to convert from \cpp{E}}
%%%%%%%%%%%%%%%%%%

An object of type \cpp{E} is not convertible to an object of type \cpp{expected<E,T>}:

The proposed interface uses a special tag \cpp{unexpect} to indicate an unexpected value expected state. It is used for construction, assignment and relational operations. This might rise a couple of objections. First, this convenience feature is not strictly necessary because you can achieve the same effect by using the \cpp{unexpect} tagged forwarding constructor:


\subsubsection{Using \cpp{make_unexpected} to convert from \cpp{E}}
%%%%%%%%%%%%%%%%%%

An object of type \cpp{E} is not convertible to an unexpected object of type \cpp{expected<E,T>}:

The proposed interface uses a special tag \cpp{unexpect} and a special non-member \cpp{make_unexpected} function to indicate an unexpected state for \cpp{expected<E,T>}. It is used for construction, assignment and relational operations. This might rise a couple of objections. First, this duplication is not strictly necessary because you can achieve the same effect by using the \cpp{unexpect} tagged forwarding constructor:

\begin{lstlisting}
expected<int, string> opt1 = make_unexpected(1); 
expected<int, string> opt2 = {unexpect, 1}; 

opt1 =   make_unexpected(1);
opt2 =  {unexpect, 1};

\end{lstlisting}

While some situations would work with {unexpect, ...} syntax, using \cpp{make_expected} makes the programmer's intention as clear and less cryptic. Compare these:

\begin{lstlisting}
expected<int, vector<int>> get1() {
  return {unexpect, 1};
}

expected<int, vector<int>> get2() {
  return make_unexpected(1);
}

expected<int, vector<int>> get3() {
  return expected<int, vector<int>>{unexpect, 1};
}
\end{lstlisting}

The usage of \cpp{make_unexpected} is also a consequence of the adapted model for expect: a discriminated union of \cpp{T} and \cpp{unexpected_type<E>}. 
While \cpp{make_unexpected(E)} has been chosen because it clearly indicates that we are interested in creating an unexpected \cpp{expected<E,T>} (of unspecified type \cpp{T}), it could be used also to make a ready future with a specific exception, but this is outside the scope of this proposal.

Note also that the definition of the result type of \cpp{make_unexpected} has explicitly deleted default constructor. This is in order to enable the reset idiom (\cpp{exp2 = {};}), which would otherwise not work because of ambiguity when deducing the right-hand side argument.

\subsubsection{Why not a \cpp{make_unexpected} nested function on \cpp{expected<E,T>}?}
%%%%%%%%%%%%%%%%%%

\cite{AlexandrescuExpected} \cpp{Expected<T>} class has a nested member function \cpp{Expected<T>::from_error(E)} instead of the free function \cpp{make_unexpected}. But the proposed \cpp{expected<E,T>} has an additional template parameter \cpp{E} and so the type \cpp{E} would be explicit.

\begin{lstlisting}
expected<unsigned, string> ei = expected<unsigned, string>::make_unexpected(1);
\end{lstlisting}

This has however several advantages. Namespace \cpp{std} is not polluted with an additional expected-specific name. Also, it resolves certain ambiguities when types like expected<E, expected<E,T>> are involved:

\begin{lstlisting}
expected<int, expected<int, string>> eei = 
    expected<int, string>::make_unexpected(1);           // valued
expected<int, expected<int, string>> eej = 
    expected<int, expected<int, string>>::make_unexpected(1); // disengaged

void fun(expected<int, string>);
void fun(expected<int, int>);

fun(expected<int, string>::make_unexpected(1)); // unambiguous: a typeless make_unexpected would not do 
\end{lstlisting}

Yet, we choose to propose a free function because we consider the above problems rare and a free function offers a very short notation in other cases:

\begin{lstlisting}
expected<int, string> fun()
{
  expected<int, string> ei = make_unexpected(1);  // no ambiguity
  ei = make_unexpected(1);                // no ambiguity
  // ...
  return make_unexpected(1);              // no ambiguity
}
\end{lstlisting}

If the typeless function does not work for you, you can always use the following construct, although at the expense of invoking a (possibly elided) move constructor:

\begin{lstlisting}
expected<int, expected<int, string>> eei = 
    expected<int, string>{make_unexpected(1)};           // valued
expected<int, expected<int, string>> eej = 
    expected<int, expected<int, string>>{make_unexpected(1)}; // unexpected

void fun(expected<int, string>);
void fun(expected<int,int>);

fun(expected<int, string>{make_unexpected(1)}); // unambiguous 
\end{lstlisting}

\subsubsection{Handling \cpp{initializer_list}}
%%%%%%%%%%%%%%%%%%

\subsection{Observers}
%%%%%%%%%%%%%%%%%%

In order to be as efficient as possible, this proposal includes observers with narrow and wide contracts. Thus, the \cpp{value()} function has a wide contract. If the expected object doesn't contains a value an exception is throw. However, when the user know that the expected object is valid, the use of \cpp{operator*} would be more appropriated. 

\subsubsection{Explicit conversion to \cpp{bool}}
%%%%%%%%%%%%%%%%%%

The same rational described in \cite{OptionalRev4} for \cpp{optional<T>} applies to \cpp{expected<E,T>} and so, the following example would combine initialization and  checking for been valued in a condition.

\begin{lstlisting}
if (expected<exception_ptr, char> ch = readNextChar()) {
  // ...
}
\end{lstlisting}


\subsubsection{Accessing the contained value}
%%%%%%%%%%%%%%%%%%

Even if \cpp{expected<E,T>} has not been used in practice for a while as Boost.Optional, we consider that following the same interface that \cpp{std::experimental::optional<T>} makes the C++ standard library more homogeneous. 

The same rational described in \cite{OptionalRev4} for \cpp{optional<T>} applies to \cpp{expected<E,T>} and so, 

\subsubsection{Function value}
%%%%%%%%%%%%%%%%%%

Using the indirection operator for a unexpected object is an undefined behavior. This behavior offers maximum runtime performance. In addition to indirection operator, we provide member function value as in \cite{OptionalRev4} that returns a reference to the contained value if one exists or throws an exception \cpp{bad_expected_access<E>} (derived from \cpp{logic_error}) otherwise:

\begin{lstlisting}
void interact() {
  std::string s;
  cout << "enter number ";
  cin >> s;
  expected<exception_ptr,int> ei = str2int(s);
  
  try {
    process_int(ei.value());
  }
  catch(bad_expected_access const&) {
    cout << "this was not a number";
  }
}
\end{lstlisting}

\cpp{bad_expected_access<E>} and \cpp{bad_optional_access} could inherit both from a \cpp{bad_access} exception derived from \cpp{logic_error}, but this is not proposed.

\subsubsection{Accessing the contained error}
%%%%%%%%%%%%%%%%%%%%%%%

Usually the access to the contained error is done once we know that the expected object has no value. This is why the \cpp{error()} function has a narrow contract, it works only if (! *this).

\begin{lstlisting}
  expected<errc,int> getIntOrZero(istream_range& r);
    auto r = getInt();  // won't throw
    if ( ! r && r.error() == errc::empty_stream ) {
        return 0;
    }
    return r;
  }
\end{lstlisting}


\subsubsection{Accessing the unexpected value}
%%%%%%%%%%%%%%%%%%

As the \cpp{error()} function the \cpp{get_unexpected()} works only if the expected object has no value. It is used to propagate errors.

\begin{lstlisting}
expected<errc, pair<int, int>> getIntRange(istream_range& r) {
  auto  f = getInt(r);
  if (! f) return f.get_unexpected();

  auto  m = matchedString("..", r);
  if (! m) return m.get_unexpected();

  auto  l = getInt(r);
  if (! l) return l.get_unexpected();

  return std::make_pair(*f, *l);
}
\end{lstlisting}

\subsubsection{Function \cpp{has_exception}}
%%%%%%%%%%%%%%%%%%%%%%%%

\cite{AlexandrescuExpected} Expected class had a \cpp{has_exception<E>} function that checks if the expected object has a stored exception that derived from E. This function has a sense only when the error parameter is a exception type erasure as \cpp{std::exception_ptr} that contains any exception. This function is useful when the user don't needs to get more information that the type of the stored exception.

\begin{lstlisting}
expected<exception_ptr,int> getIntOrZero(istream_range& r) {
    auto r = getInt();  // won't throw
    if (r.has_exception<EmptyStream>() {
        return 0;
    }
    return r;
}
\end{lstlisting}


\subsubsection{Function \cpp{catch_exception}}
%%%%%%%%%%%%%%%%%%

When the user wants to retrieve the whole information on the stored exception the function \cpp{catch_exception}  can be used.

\begin{lstlisting}
  expected<exception_ptr,int> getIntOrZero(istream_range& r) 
  {
    return getInt().
    catch_exception<NotANumber>([](auto& ex) // (1)
    {  // has complete access to the stored 
  
    });   // try to recover
  }
\end{lstlisting}


\subsubsection{Function \cpp{value_or}}
%%%%%%%%%%%%%%%%%%

This function template returns a value stored by the \cpp{expected} object if it is valued, and if not, it falls back to the default value specified in the second argument. This method for specifying default values on the fly rather than tying the default values to the type is based on the observation that different contexts or usages require different default values for the same type. For instance the default value for \cpp{int} can be \cpp{0} or \cpp{-1}. The callee might not know what value the caller considers special, so it returns the lack of the requested value explicitly. The caller may be better suited to make the choice what special value to use.

\begin{lstlisting}
expected<exception_ptr,int> queryDB(std::string);
void setPieceCount(int);
void setMaxCount(int);

setPieceCount( queryDB("select piece_count from ...").value_or(0) );
setMaxCount( queryDB("select max_count from ...").value_or(numeric_limits<int>::max()) );
\end{lstlisting}

The decision to provide this function is controversial itself. As pointed out by Robert Ramey, the goal of the optional is to make the lack of the value explicit. Its syntax forces two control paths; therefore we will typically see an if-statement (or similar branching instruction) wherever expected is used. This is considered an improvement in correctness. On the other hand, using the default value appears to conflict with the above idea. One other argument against providing it is that in many cases you can use a ternary conditional operator instead:

\begin{lstlisting}
auto&& cnt = queryDB("select piece_count from ...");
setPieceCount(cnt ? *cnt : 0);

auto&& max = queryDB("select max_count from ...");
setMaxCount(max ? std::move(*max) : numeric_limits<int>::max());
\end{lstlisting}

However, in case expected objects are returned by value and immediately consumed, the ternary operator syntax requires introducing an lvalue. This requires more typing and explicit move. This in turn makes the code less safe because a moved-from lvalue is still accessible and open for inadvertent misuse.

There are reasons to make it a free-standing function. (1) It can be implemented by using only the public interface of optional. (2) This function template could be equally well be applied to any type satisfying the requirements of \cpp{NullableProxy}. In this proposal, function \cpp{value_or} is defined as a member function. Making a premature generalization would risk standardizing a function with suboptimal performance/utility. While we know what detailed semantics (e.g., the return type) \cpp{value_or} should have for \cpp{expected}, we cannot claim to know the ideal semantics for any \cpp{NullableProxy}. Also, it is not clear to us if this convenience function is equally useful for pointers, as it is for optional objects. By making \cpp{value_or} a member function we leave the room for this name in namespace \cpp{std} for a possible future generalization.

The second argument in the function template's signature is not \cpp{T} but any type convertible to \cpp{T}:

\begin{lstlisting}
template <class T, class E, class V> 
  typename T expected<E,T>::value_or(V&& v) const&;
template <class T, class E, class V> 
  typename T expected<E,T>::value_or(V&& v) &&;
\end{lstlisting}

This allows for a certain run-time optimization. In the following example:

\begin{lstlisting}
expected<int, string> ex{"cat"};
string ans = ex.value_or("dog");

Because the expected object is valued, we do not need the fallback value and therefore to convert the string literal "dog" into type \cpp{string}.

It has been argued that the function should return by constant reference rather than value, which would avoid copy overhead in certain situations:

\begin{lstlisting}
void observe(const X& x);

expected<exception_ptr,X> ex { /* ... */ };
observe( ex.value_or(X{args}) );    // unnecessary copy
\end{lstlisting}

However, the benefit of the function \cpp{value_or} is only visible when the optional object is provided as a temporary (without the name); otherwise, a ternary operator is equally useful:

\begin{lstlisting}
expected<exception_ptr,X> ex { /* ... */ };
observe(ox ? *ek : X{args});            // no copy
\end{lstlisting}

Also, returning by reference would be likely to render a dangling reference, in case the expected object is invalid, because the second argument is typically a temporary:

\begin{lstlisting}
expected<exception_ptr,X> ex {};
auto&& x = ex.value_or(X{args});
cout << x;                              // x is dangling!
\end{lstlisting}

There is also one practical problem with returning a reference. The function takes two arguments by reference: the expected object and the default value. It can happen that one is deduced as lvalue reference and the other as rvalue reference. In such case we would not know what kind of reference to return. Returning lvalue reference might prevent move optimization; returning an rvalue reference might cause an unsafe move from lvalue. By returning by value we avoid these problems by requiring one unnecessary move in some cases.

We also do not want to return a constant lvalue reference because that would prevent a copy elision in cases where optional object is returned by value.

As for \cpp{std::experimental::optional<T>} the function \cpp{expected<E,T>::value_or<V>} could return type \cpp{decay_t<common_type_t<T, V>} rather than \cpp{T}. This would avoid certain problems, such as loss of accuracy on arithmetic types:

\begin{lstlisting}
// not proposed
expected<E,int> op = /* ... */;
long gl = /* ... */;

auto lossless = op.value_or(gl);   // lossless deduced as long rather than int
\end{lstlisting}

However, to be alined with \cpp{std::experimental::optional<T>}  we do not propose it at this time.

Together with function \cpp{value}, \cpp{value_or} makes a set of similarly called functions for accessing the contained value that do not cause an undefined behavior when invoked on a invalid expected (at the expense of runtime overhead). They differ though, in the return type: one returns a value, the other a reference.

\subsubsection{Relational operators}
%%%%%%%%%%%%%%%%%%

As \cpp{optional}, one of the design goals of \cpp{expected} is that objects of type \cpp{expected<E,T>} should be valid elements in STL containers and usable with STL algorithms (at least if objects of type \cpp{T} and \cpp{E} are). Equality comparison is essential for \cpp{expected<E,T>} to model concept \cpp{Regular}. C++ does not have concepts, but being regular is still essential for the type to be effectively used with STL. Ordering is essential if we want to store expected values in ordered associative containers. A number of ways of including the unexpected state in comparisons have been suggested. The ones proposed, have been crafted such that the axioms of equivalence and strict weak ordering are preserved: unexpected values stored in \cpp{expected<E,T>} are simply treated as additional values that are always different from \cpp{T}; these values are always compared as less than any value of \cpp{T} when stored in an expected object. 

   
The main issue is how to compare the unexpected values between them.  \cpp{operator==()} is defined for \cpp{exception_ptr}, using shallow semantics but there is no order between two \cpp{exception_ptr}.

\begin{lstlisting}
template <class T, class E>
constexpr bool operator<(const expected<E,T>& x, const expected<E,T>& y)
{
  return (x)
       ? (y) ? *x < *y : true
       : (y) ? true : ?<?;
}

template <class T, class E>
constexpr bool operator==(const expected<E,T>& x, const expected<E,T>& y)
{
    return (x)
         ? (y) ? *x == *y : false
         : (y) ? false : ?==?;
}
\end{lstlisting}

If we follow the \cpp{optional<T>} semantics, two unexpected values should always be equal and do not compare. That is, \cpp{?<?} should be substituted by \cpp{false} and \cpp{?==?} by \cpp{true}. But considering all the unexpected value equals seems counterintuitive.

The alternative consists in forwarding the request to the respective  \cpp{unexpected_type<E>} relational operators.That is, \cpp{?<?} should be substituted by \cpp{x.get_unexpected() < y.get_unexpected()} and \cpp{?==?} by \cpp{x.get_unexpected() == y.get_unexpected()}. But how to define the relational operators for \cpp{unexpected_type<E>}? We can forward the request to the respective \cpp{E} relational operators when \cpp{E} defines these operators and follows the \cpp{optional<T>} semantics otherwise. 

The case of \cpp{unexpected_type<std::exception_ptr>} could follow the \cpp{optional<T>} semantics as the shallow comparison is not very useful.

This limitation is one of the main motivations for having a user defined type with strict weak ordering. E.g. if the user know the exact types of the exceptions that can be thrown \cpp{E1}, ..., \cpp{En}, the error parameter could be some kind of \cpp{variant<E1, ... En>} for which a strict weak ordering can be defined. If the user would like to take care of unknown exceptions something like \cpp{optional<variant<E1, ... En>>} would be a quite appropriated model. 

\begin{lstlisting}
expected<int, unsigned> e0{0};
expected<int, unsigned> e1{1};
expected<int, unsigned> eN{unexpect, -1};

assert (eN < e0);
assert (e0 < e1);
assert (!(eN  < eN));
assert (!(e1 < e1));

assert (eN != e0);
assert (e0 != e1);
assert (eN == eN);
assert (e0 == e0);
\end{lstlisting}

Unexpected values could have been as well considered greater than any value of \cpp{T}. The choice is a great degree arbitrary. We choose to stick to what \cpp{std::optional} does.

Given that both \cpp{unexpected_type<E>} and \cpp{T} are implicitly convertible to \cpp{expected<E,T>}, this implies the existence and semantics of mixed comparison between \cpp{expected<E,T>} and \cpp{T}, as well as between \cpp{expected<E,T>} and \cpp{unexpected_type<E>}:

\begin{lstlisting}
assert (eN == make_unexpected(1));
assert (e0 != make_unexpected(1));
assert (eN != 1);
assert (e1 == 1);

assert (eN < 1);
assert (e0 > make_unexpected(1));
\end{lstlisting}

Although it is difficult to imagine any practical use case of ordering relation between \cpp{expected<E,T>} and \cpp{unexpected_type<E>}, we still provide it for completness sake.

The mixed relational operators, especially these representing order, between \cpp{expected<E,T>} and \cpp{T} have been accused of being dangerous. In code examples like the following, it may be unclear if the author did not really intend to compare two \cpp{T}'s.

\begin{lstlisting}
auto count = get_expected_count();
if (count < 20) {}                        // or did you mean: *count < 20 ?
if (! count || *count < 20) {}   // verbose, but unambiguous
\end{lstlisting}

Given that \cpp{expected<E,T>} is comparable and implicitly constructible from \cpp{T}, the mixed comparison is there already. We would have to artificially create the mixed overloads only for them to cause controlled compilation errors. A consistent approach to prohibiting mixed relational operators would be to also prohibit the conversion from \cpp{T} or to also prohibit homogenous relational operators for \cpp{expected<E,T>} ; we do not want to do either, for other reasons discussed in this proposal. Also, mixed relational operations are available in \cpp{std::optional<T>} and we want to maintain the same behavior for \cpp{expected<nullopt_t,T>} and \cpp{optional<T>}. Mixed operators come as something natural when we consider the model "T with additional values".

For completeness sake, we also provide ordering relations between  \cpp{expected<E,T>} and  \cpp{unexpected_type<E>}, even though we see no practical use case for them:

\begin{lstlisting}
bool test(expected<unsigned, int> e)
{
  assert (e >= make_unexpected(1));    
  assert (!(e < make_unexpected(1)));  
  assert (make_unexpected(1) <= e);    
  return (e > make_unexpected(1));     
}
\end{lstlisting}

There exist two ways of implementing \cpp{operator>()} for expected objects: use \cpp{T::operator>()} or use \cpp{expected<E,T>::operator<()}

In case \cpp{T::operator>} and \cpp{T::operator<} are defined consistently, both above implementations are equivalent. If the two operators are not consistent, the choice of implementation makes a difference. 

For relational operations, we choose to implement all in terms of  \cpp{expected<E,T>::operator<()} to be consistent with the choice taken for \cpp{std::optional}.

The same applies to the relational operators for \cpp{unexpected_type<E>} .

\subsection{Modifiers}
%%%%%%%%%%%%%%%%%%

\subsubsection{Reseting the value}
%%%%%%%%%%%%%%%%%%

Assigning the value of type \cpp{T} to \cpp{expected<E,T>} object results in doing two different things based on whether the expected object has a value or not. If expected object has a value, the contained value is assigned a new value. If expected object has an unexpected value, the destructor of the unexpected value is called and then it becomes valued using \cpp{T}'s copy/move constructor. This behavior is based on a silent assumption that \cpp{T}'s copy/move constructor is copying a value in a similar way to copy/move assignment. A similar logic applies to \cpp{expected<E,T>}'s copy/move assignment, although the situation here is more complicated because we have two valued/unexpected states to be considered. This means that \cpp{expected<E,T>}'s assignment does not work (does not compile) if \cpp{T} is not assignable:

\begin{lstlisting}
expected<int,const int> ei = 1;  // ok
ei = 2;                      // error 
ei = ei;                     // error 
ei = make_unexpected(1);                // ok
\end{lstlisting}

There is an option to reset the value of optional object without resorting to \cpp{T}'s assignment:

\begin{lstlisting}
expected<int, const int> ej = 1;  // ok
ej.emplace(2);               // ok 
\end{lstlisting}

Function emplace disengages the optional object if it is engaged, and then just engages the object anew by copy-constructing the contained value. It is similar to assignment, except that it is guaranteed not to use T's assignment and provides only a basic exception safety guarantee. In contrast, assignment may provide a stronger guarantee if T's assignment does.

To sumarize, this proposal offers three ways of assigning a new contained value to an optional object:

\begin{lstlisting}
optional<int> e;
e = make_optional(1);         // copy/move assignment
e = 1;                        // assignment from T
e.emplace(1);                 // emplacement 
\end{lstlisting}

The first form of assignment is required to make optional a regular object, useable in STL. We need the second form in order to reflect the fact that optional<T> is a wrapper for T and hence it should behave as T as much as possible. Also, when optional<T> is viewed as T with one additional value, we want the values of T to be directly assignable to optional<T>. In addition, we need the second form to allow the interoperability with function std::tie as shown above. The third option is required to be able to reset an optional non-assignable T.

\subsubsection{Tag \cpp{in_place}}
%%%%%%%%%%%%%%%%%%

This proposal makes use of the 'in-place' tag defined in \cite{OptionalRev5}. This proposal  provides the same kind of 'in-place' constructor that forwards (perfectly) the arguments provided to \cpp{expected}'s constructor into the constructor of \cpp{T}. In order to trigger this constructor one has to use the tag struct \cpp{in_place}. We need the extra tag to disambiguate certain situations, like calling \cpp{expected}'s default constructor and requesting \cpp{T}'s default construction:

\begin{lstlisting}
expected<int,Big> eb{in_place, "1"}; // calls Big{"1"} in place (no moving)
expected<int,Big> ec{in_place};      // calls Big{} in place (no moving)
expected<int,Big> ed{};             // creates a unexpected expected
\end{lstlisting}


\subsubsection{Tag \cpp{unexpect}}
%%%%%%%%%%%%%%%%%%

This proposal provides an 'unpect' constructor that forwards (perfectly) the arguments provided to \cpp{expected}'s constructor into the constructor of \cpp{E}. In order to trigger this constructor one has to use the tag struct \cpp{unexpect}. We need the extra tag to disambiguate certain situations, like calling \cpp{expected}'s default constructor and requesting \cpp{T}'s default construction:

\begin{lstlisting}
expected<int, Big> eb{unexpect, "1"}; // calls Big{"1"} in place (no moving)
expected<int, Big> ec{unexpect};      // calls Big{} in place (no moving)
\end{lstlisting}

In order to make the tag uniform an additional 'expect' constructor could be provided but this proposal doesn't propose it.

\subsubsection{Requirements}

The \cpp{expected<std::exception_ptr,T>} specialization introduces some operations as \cpp{has_unexpected} and \cpp{catch_unexcpected}. Should we name the classes differently? For example, \cpp{exception_or<T>} and \cpp{error_or<E,T>}.

\subsubsection{Requirements on \cpp{T}and \cpp{E}}
%%%%%%%%%%%%%%%%%%

Class template \cpp{expected} imposes little requirements on \cpp{T} and \cpp{E}: they have to be  complete object type satisfying the requirements of \cpp{Destructible}. It is the particular operations on \cpp{expected<E,T>} that impose requirements on \cpp{T} and \cpp{E}: \cpp{expected<E,T>}'s move constructor requires that \cpp{T} and \cpp{E} are \cpp{MoveConstructible}, \cpp{expected<E,T>}'s copy constructor requires that \cpp{T} and \cpp{E} are \cpp{CopyConstructible}, and so on. This is because \cpp{expected<E,T>} is a wrapper for \cpp{T} or \cpp{E}: it should resemble \cpp{T} as much as possible. If \cpp{T} is \cpp{EqualityComparable} then (and only then) we expect \cpp{expected<E,T>} to be \cpp{EqualityComparable}. 


\subsubsection{Expected references}
%%%%%%%%%%%%%%%%%%

This proposal doesn't include expected references as \cite{optional} doesn't  includes optional references neither.

\subsubsection{Expected void}
%%%%%%%%%%%%%%%%%%

While it could seem weird to instantiate optional with \cpp{void}, it has more sense for expected as expected conveys in addition, as \cpp{future<T>},  an error code. \cpp{expected<E,void>} 

\subsubsection{\cpp{NullableProxy}}
%%%%%%%%%%%%%%%%%%

As optional objects, the primary purpose of expected object is to check if they contain a value and if so, to provide access to this value. We observe that a similar functionality is offered by raw and smart pointers, except for the "contains" part: pointers do not contain the value they point to. Nonetheless, expected objects, optional objects and pointers have enough things in common that certain class of generic functions can be written that can be used with either. We call the identified concept \cpp{NullableProxy}. Basically, the concept indicates that a type is a 'proxy' for another type. The operations allowed are: checking if there exists an object that our proxy can indirect us to and the indirection operation. The operations can be summarized by the following use-case:

\begin{lstlisting}
temmplate <class NullableProxy>
void test(NullableProxy&& np)
{
  if (np)              // 'has-object' check
    auto&& obj = *np;  // object access
  if (!np) {}          // 'doesn't have object'
}
\end{lstlisting}

These requirements are sufficient to specify a couple of generic functions (not proposed), like the one below:

\begin{lstlisting}
template <typename NullableProxy>
// enable_if: decltype(*declval<NullableProxy>()) is EqualityComparable
bool equal_pointees( const NullableProxy& x, const NullableProxy& y )
{
  return bool(x) != bool(y) ? false : ( x ? *x == *y : true );
}
\end{lstlisting}

This is exactly the logic for the equality comparison of optional values, and could be used as an implementation of \cpp{expecte<T>::operator==}. A similar algorithm for less-than comparison can be specified. The third example is function \cpp{value_or} discussed below. Another example is function \cpp{as_ptr} discussed below, for providing raw pointer access to a possibly-null proxied value.

Requirements \cpp{NullableProxy} overlap with requirements \cpp{NullablePointer}. Their common part could be extracted to separate requirements, say \cpp{Nullable}, but these requirements are too small to be useful alone for anything.

We do not propose to add \cpp{NullableProxy} to Library at this time, as the usage base may be too small for justifying the change. It may prove a useful addition in the future.

\subsection{Literals}

\subsubsection{Making \cpp{expected} a literal type}
%%%%%%%%%%%%%%%%%%

We propose that \cpp{expected<E,T>} be a literal type for trivially destructible \cpp{T}'s and \cpp{E}'s.

\begin{lstlisting}
constexpr expected<int, int> ei{5};
static_assert(ei, "");            // ok
static_assert(ei == ei, "");      // ok
int array[*ei];                   // ok: array of size 5 
\end{lstlisting}

Making \cpp{expected<E,T>} a literal-type in general is impossible: the destructor cannot be trivial because it has to execute an operation that can be conceptually described as:

~expected() {
  if (valid()) destroy_contained_value();
  else destroy_contained_error();
}

It is still possible to make the destructor trivial for \cpp{T}'s and \cpp{E}'s which provide a trivial destructor themselves, and we know an efficient implementation of such  \cpp{expected<E,T>}  with compile-time interface ? except for copy constructor and move constructor ? is possible. Therefore we propose that for trivially destructible \cpp{T}'s and \cpp{E}'s all \cpp{expected<E,T>}'s constructors, except for move and copy constructors, as well as observer functions are constexpr. The sketch of reference implementation is provided in \cite{boost.expected}.

We need to make a similar exception for \cpp{operator->} for types with overloaded \cpp{operator&}. The common pattern in the library is to use function \cpp{addressof} to avoid the surprise of overloaded \cpp{operator&}. However, we know of no way to implement constexpr version of function template addressof. The best approach we can take is to require that for normal types the non-overloaded (and constexpr) \cpp{operator&} is used to take the address of the contained value, and for the tricky types, implementations can use the normal (non-constexpr) \cpp{addressof}. 

\subsubsection{Moved from state}
%%%%%%%%%%%%%%%%%%

When a valued expected object is moved from (i.e., when it is the source object of move constructor or move assignment) its state does not change. When a valued object is moved from, we move the contained value, but leave the expected object valued. A moved-from contained value is still valid (although possibly not specified), so it is fine to consider such expected object valued. An alternative approach would be to destroy the contained value and make the moved-from optional object unvalid. However, we do not propose this for performance reasons.

In contexts, like returning by value, where you need to call the destructor the second after the move, it does not matter, but in cases where you request the move explicitly and intend to assign a new value in the next step, and if \cpp{T} does not provide an efficient move, the chosen approach saves an unnecessary destructor and constructor call:

\begin{lstlisting}
expected<errc,array<Big, 1000>> eo = ... // array doesn't have efficient move
ep = std::move(eo);
eo = std::move(tmp);
\end{lstlisting}

The following is an even more compelling reason. In this proposal \cpp{expected<int,int>} is allowed to be implemented as a TriviallyCopyable type. Therefore, the copy constructor of type \cpp{std::array<expected<int,int>, 1000>} can be implemented using \cpp{memcpy}. With the additional requirement that expected's move constructor should not be trivial, we would be preventing the described optimization.

The fact that the moved-from expected is not invalid may look "uncomfortable" at first, but this is an invalid expectation. The requirements of library components expressed in 17.6.5.15 (moved-from state of library types) only require that moved-from objects are in a valid but unspecified state. We do not need to guarantee anything above this minimum.

\subsection{Other}

\subsubsection{IO operations}
%%%%%%%%%%%%%%%%%%

The proposed interface for expected values does not contain IO operations: \cpp{operator<<} and \cpp{operator>>}. While we believe that they would be a useful addition to the interface of expected objects, we also observe that there are some technical obstacles in providing them, and we choose not to propose them at this time. Library components like optional, containers, pairs, tuples face the same issue. At present IO operations are not provided for these types. Our preference for \cpp{expected} is to provide an IO solution compatible with this for optional, containers, pairs and tuples, therefore at this point we refrain from proposing a solution for \cpp{expected} alone.


\subsubsection{Function \cpp{make_expected}}
%%%%%%%%%%%%%%%%%%

\subsection{Monad-like operations}
%%%%%%%%%%

\cite{ImprovementsAsync} propose some improvements to \cpp{std::future<T>} that can be adapted to \cpp{expected<E,T>} naturally.

\subsubsection{When ready}
%%%%%%%%%%

\cite{ImprovementsAsync} provides a \cpp{future<T>.then()} function that accepts a continuation having the future object as parameter. This continuation function is called when the future becomes ready. Been expected always ready this function is less useful. The single role would be to adapt the result of the continuation to the expected.

\subsubsection{When valued/unexpected}
%%%%%%%%%%

In addition the \cpp{.then()} function that accepts a continuation having the expected object as parameter, the proposal includes two separated functions, one \cpp{.next()} that applies when the expected object is valued and accepts a continuation having the underlying \cpp{value_type} as parameter. The other \cpp{.recover()} applies when the expected object is not valid and is used to try to recover from the error.  

\subsubsection{Continuation adaptors}
%%%%%%%%%%

An alternative to these specific functions could be to use the \cpp{.then()} function and have some adaptor \cpp{if_valued} and \cpp{if_unexpected} that do the adaptation.

\begin{lstlisting}
f.then(if_valued([](T v) {...}));

f.then(if_unexpected([](E e) {...}));
\end{lstlisting}

TBoost.Expected \cite{boost_expected} provides such a \cpp{.then} continuation adaptors, but this proposal doesn't include them.

\subsubsection{\cpp{value_or_call}}
%%%%%%%%%%

As reported in \cite{OPTIONAL_R5} one  convenience function has been suggested. Sometimes the default value is not given, and computing it takes some time. We only want to compute it, when we know the optional object is disengaged:

\begin{lstlisting}
expected<exception_ptr,int> ei = /* ... */;

if (ei) {
  use(*ei);
}
else {
  int i = painfully_compute_default();
  use(i);
}
\end{lstlisting}

The solution to that situation would be another convenience function which rather than taking a default value takes a callable object that is capable of computing a default value if needed:

\begin{lstlisting}
use( ei.value_or_call(&painfully_compute_default) );       
// or
use( ei.value_or_call([&]{return painfully_compute_default();} );
\end{lstlisting}

This is quite close to the context of use of  \cpp{recover}, but the function called has no parameter. As there is an alternative using generic lambdas this proposal doesn't propose neither this function.

\begin{lstlisting}
ei.restore([](auto){ return painfully_compute_default();}).next(use);       
\end{lstlisting}

\subsubsection{When all ready}
%%%%%%%%%%

 \cite{ImprovementsAsync} includes \cpp{when_all()/when_any()//when_any_swaped()} functions to group futures on a new specific future that will be ready under different circumstances. As \cpp{expected<E,T>} is always ready, these functions have no sense. If provided the result and the behavior would be the same for both, just group all the expected.  
 
\subsubsection{When all valued}
%%%%%%%%%%

However, there is yet a need to apply a function when all the expected are valued. The free function \cpp{next()} takes a variadic continuation and a variadic number of expected parameters. The type and number of the parameters must be compatible with the continuation arguments.

\begin{lstlisting}
 expected<exception_ptr,int> sumFirstAndSecond5(istream_range& r)
{
  return next(add, getInt(r), getInt(r));
}
\end{lstlisting}

An alternative to this specific function if \cpp{when_all} is provided, could be to use the \cpp{.then()} function and have some adaptor \cpp{if_all_valued} that do the adaptation.

\begin{lstlisting}
expected<exception_ptr,int> sumFirstAndSecond5(istream_range& r)
{
  return when_all(getInt(r), getInt(r)).then(if_all_valued([](int i, int j) {...}));
}
\end{lstlisting}

\subsubsection{When any valued}
%%%%%%%%%%

The authors don't have a concrete use case for a function that would be applied if any of the expected has a value other than looking for non-determinism.

\subsubsection{\cpp{expected<E, expected<E,T>>}}
%%%%%%%%%%


\subsubsection{Function \cpp{unwrap}}
%%%%%%%%%%

In some scenarios, you might want to create an \cpp{expected} that returns another \cpp{expected}, resulting in nested expected. 
It is possible to write simple code to unwrap the outer \cpp{expected} and retrieve the nested \cpp{expected} and its result with the current interface as in

\begin{lstlisting}
template <class T, class E>
expected<E,T> unwrap<expected<E, expected<E,T>> ee) {
  if (ee) return *ee;
  return ee.get_unexpected();
}
template <class T, class E>
expected<E,T> unwrap<expected<E,T>> e) {
  return e;
}
\end{lstlisting}

We could add such a function to the standard, either as a free function or as a member function. The authors propose to add it as a free function.

Note that in this proposal the single function that could nest expected is \cpp{make_expected}. The factory functions \cpp{then},\cpp{next} and\cpp{restore} unwrap automatically. Maybe  \cpp{make_expected} should unwrap automatically also.

\section{Related types}
%%%%%%%%%%%

\subsection{Variant}
%%%%%%%%%%%%%%%%%%%%

\cpp{expected<E,T>} can be seen as a specialization of  \cpp{boost::variant<unexpected<E>,T>} which gives a specific intent to its second parameter, that is, it represent the type of the expected contained value. This specificity allows to provide a pointer like interface, as it is the case for \cpp{std::experimental::optional<T>}. Even if the standard included a class  \cpp{variant<T,E>}, the interface provided by \cpp{expected<E,T>} is more specific and closer to what the user could expect as the result type of a function. In addition, \cpp{expected<E,T>} doesn't intend to be used to define recursive data as \cpp{boost::variant<>} does.

The table \ref{comp-variant} presents a brief comparison between \cpp{boost::variant<T, E>} and \cpp{expected<E,T>}.

\begin{table}
\bgroup
\def\arraystretch{1.5}
\begin{tabular}
{|l|>{\raggedright\arraybackslash}p{6cm}|>{\raggedright\arraybackslash}p{6cm}|}
\hline
                    & \textbf{boost::variant<unexpected<E>, T>} & \textbf{expected<E,T>}  \\
\hline
\textbf{never-empty warranty} & yes & yes \\
\hline
\textbf{accepts is_same<T,E>} & no & yes \\
\hline
\textbf{swap} & yes & yes \\
\hline
\textbf{factories} & no & make\_expected / make\_unexpected  \\
\hline
\textbf{hash} & yes & yes  \\
\hline
\textbf{value_type} & no & yes  \\
\hline
\textbf{default constructor} & yes (if T is default constructible) & yes (if T is default constructible)  \\
\hline
\textbf{observers} & boost::get<T> and boost::get<E> & pointer-like / value / error / value_or / value_or_throw \\
\hline
\textbf{continuations} & apply_visitor & then/next/recover  \\
\hline
\end{tabular}
\egroup
\caption{Comparison between variant and expected.}
\label{comp-variant}
\end{table}


\subsection{Optional}
%%%%%%%%%%%

We can see \cpp{expected<E,T>} as an \cpp{std::experimental::optional<T>} that collapse all the values of \cpp{E} to \cpp{nullopt}. 

We can convert an \cpp{expected<E,T>} to an \cpp{optional<T>} with the possible loss of information.

\begin{lstlisting}
template <class T>
optional<T> make_optional(expected<E,T> v) {
  if (v.valid()) return make_optional(*v);
  else nullopt;
}
\end{lstlisting}

We can convert an \cpp{optional<T>} to an \cpp{expected<exception_ptr,T>} without knowledge of the root cause.

\begin{lstlisting}
template <class T>
expected<exception_ptr,T> make_expected(optional<T> v) {
  if (v.valid()) return make_expected(*v);
  else make_unexpected(conversion_from_nullopt());
}
\end{lstlisting}

\subsection{Promise and Future}
%%%%%%%%%%%%%%%%%

We can see \cpp{expected<exception_ptr,T>} as a always ready \cpp{future<T>}.
While \cpp{promise<>}/\cpp{future<>} focuses on inter-thread asynchronous communication, \cpp{excepted<E,T>} focus on eager and synchronous computations.
We can move a ready \cpp{future<T>} to an \cpp{expected<exception_ptr,T>} with no loss of information. 

\begin{lstlisting}
template <class T>
expected<exception_ptr,T> make_expected(future<T>&& f) {
  assert (f.ready() && "future not ready");
  try {
    return f.get();
  } catch (...) {
    return make_unexpected_from_exception();
  }
}
\end{lstlisting}

Remark: in line (1) we could use instead \cpp{std::future<T>::get_exception_ptr()}, which is now provided by Boost.Thread, that can be implemented by the library more efficiently than the user could do.

We can create also a \cpp{future<T>} from an \cpp{expected<exception_ptr,T>}.

\begin{lstlisting}
template <class T>
future<T> make_ready_future(expected<exception_ptr,T> e) {
  if (e.valid()) 
    return make_ready_future(*e);
  else 
    return make_unexpected_future<T>(e.error()); 
}
\end{lstlisting}

where

\begin{lstlisting}
template <class T, class E>
constexpr future<T> make_unexpected_future(E e)  {
  promise<T> p;
  future<T> f = p.get_future();
  p.set_exception(e);
  return move(f);
}
\end{lstlisting}

We can combine them as follows

\begin{lstlisting}
fut.then([](future<int> f) { 
  return make_ready_future(
    make_expected(f).next([](i){ ... }).recover(...));
  });
\end{lstlisting}


\subsection{Expected monad}
%%%%%%%%%%%%%%%

As for the \cpp{future<T>} proposal, \cpp{expected<E,T>} provides also a way to visit the stored values.
\cpp{future<T>} provides a \cpp{then()} function that accepts a continuation having the \cpp{future<T>} as parameter. The synchronous nature of expected makes it easier to use two functions, one to manage with the case expected has a value and one to try to recover otherwise. This is more in line with the monad interface, as any function having a \cpp{T} as parameter can be used as parameter of the apply function, no need to have a \cpp{expected<E,T>}. This make it easier to reuse functions. 

\begin{itemize}
 \item \cpp{expected<E,T>::next()}/\cpp{expected<E,T>::recover()} are the counterpart of \cpp{future<T>.then()}
 \item \cpp{expected<E,T>::unwrap()} is the counterpart of \cpp{future<T>.unwrap()}
 \item \cpp{expected<E,T>::valid()} is the counterpart of \cpp{future<T>.has_value()}
\end{itemize}

\subsection{Comparison between optional, expected and future}

The table \ref{comp-monads} presents a brief comparison between \cpp{optional<T>}, \cpp{expected<E,T>}  and \cpp{promise<T>/future<T>}.

\begin{table}
\bgroup
\def\arraystretch{1.5}
\begin{tabular}{|l|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{4cm}|}
\hline
                    & \textbf{optional} & \textbf{expected} & \textbf{promise/future} \\
\hline
\textbf{specific null value} & yes & no & no \\
\hline
\textbf{relational operators} & yes & yes & no \\
\hline
\textbf{swap} & yes & yes & yes \\
\hline
\textbf{factories} & make_optional / nullopt & make_expected / make_unexpected & make_ready_future / (make_exceptional, see \cite{MoreAsync}) \\
\hline
\textbf{hash} & yes & yes & yes \\
\hline
\textbf{value_type} & yes & yes & no / (yes, see \cite{MoreAsync}).  \\
\hline
\textbf{default constructor} & yes & yes (if T is default constructible) & yes \\
\hline
\textbf{allocators} & no & no & yes \\
\hline
\textbf{emplace} & yes & yes & no \\
\hline
\textbf{bool conversion} & yes & yes & no \\
\hline
\textbf{state} & bool()  & valid / bool() & valid / ready / (has_value, see \cite{MoreAsync}) \\
\hline
\textbf{observers} & pointer-like / value / value_or & pointer-like / value / error / value_or / value_or_throw & get / (get_exception_ptr, see \cite{MoreAsync}) \\
\hline
\textbf{continuations} & no & then/next/recover  & then / (next/recover see \cite{MoreAsync}) \\
\hline
\textbf{grouping} & n/a & n/a & when_all / when_any \\
\hline
\textbf{apply} & no & next & no \\
\hline
\end{tabular}
\egroup
\caption{Comparison between optional, expected and promise/future.}
\label{comp-monads}
\end{table}

\section{Open questions}
%%%%%%%%%%%%%

\subsection{Allocator support}
%%%%%%%%%%%%%%%

As \cpp{optional<T>},  \cpp{expected<E,T>} does not allocate memory. So it can do without allocators. However, it can be useful in compound types like:

\begin{lstlisting}
typedef vector< expected<erroc, vector<int, MyAlloc>>, MyAlloc>; MyVec;
MyVec v{ v2, MyAlloc{} };
\end{lstlisting}

One could expect that the allocator argument is forwarded in this constructor call to the nested vectors that use the same allocator. Allocator support would enable this. \cpp{std::tuple} offers this functionality.

\subsection{Which exception throw when the user try to get the expected value but there is none?}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

It has been suggested to let the user decide the Exception that would be throw when the user try to get the expected value but there is none, as third parameter. 

While there is no major complexity doing it, as it just needs a third parameter that could default to the appropriated class, 

\begin{lstlisting}
template <class T, class Error, class Exception = bad_expected_access>
  struct expected;
\end{lstlisting}

the authors consider that this is not really needed and that this parameter should not really be part of the type. In addition \cpp{OPTIONAL}

The user can use \cpp{value_or_throw()} as

\begin{lstlisting}
std::expected<std::error_code, int> f();
std::expected<std::error_code, int> e = f();
auto i = e.value_or_throw<std::system_error>();  
\end{lstlisting}

The user can also wrap the proposed class in its own expected class

\begin{lstlisting}
template <class T, class Error=std::error_code, class Exception=std::system_error>
struct MyExpected {
  expected <T,E> v;
  MyExpected(expected <T,E> v) : v(v) {}
  T value() {  
    if (e.valid()) return v.value();
    else throw Exception(v.error());
  }
  ...
};
\end{lstlisting}

and use it as

\begin{lstlisting}
std::expected<std::error_code, int> f();
MyExpected<int> e = f();
auto i = e.value();  // std::system_error throw if not valid
\end{lstlisting}

A class like this one could be added to the standard, but this proposal doesn't request it. 

An alternative could be to add a specialization on a error class that gives the storage and the exception to thrown.

\begin{lstlisting}
template <class Error, class Exception>
  struct error_exception {
    typedef Error error_type;
    typedef Exception exception_type;
  };
\end{lstlisting}

\begin{lstlisting}
std::expected<std::error_exception<std::error_code, std::system_error>, T> e = make_unexpected(err);
e.value(); // will thow std::system_error(err);
\end{lstlisting}


\subsection{About \cpp{expected<T, ErrorCode, Exception>}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

It has been suggested also to extend the design into something that contains 

\begin{itemize}
\item a T, or
\item an error code, or
\item a \cpp{exception_ptr} 
\end{itemize}

Again there is no major difficulty to implement it, but instead of having one variation point we have two, that is, is there a value, and if not, if is there an exception_ptr. While this would need only an extra test on the exceptional case, the authors think that it is not worth doing it as all the copy/move/swap operations would be less efficient. 

%%%%%%%%%%%%%%
\section{Proposed Wording}
%%%%%%%%%%%%%%


The proposed changes are expressed as edits to N3908, the Working Draft - C++ Extensions for Library Fundamentals \cite{FundamentalsV1}. The wording has been adapted from the section  "Optional objects".
\newline

Insert a new section. 

\wordingSec{Unexpected objects}{expected}
%%%%%%%%%%%%%%%%%%%%%

\wordingSubSec{In general}{unexpected.general}
%%%%%%%%%%%%%%%%%%%%%%%%

This subclause describes class template \cpp{unexpected_type} that wraps objects intended as unexpected. This wrapped unexpected object is used to be implicitly convertible to other object.

\wordingSubSec{Header <experimental/unexpected> synopsis}{unexpected.synop}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
  // \ref{unexpected.object}, Unexpected object type
  template <class E>
  struct unexpected_type; 
  // \ref{unexpected.exception_ptr}, Unexpected exception_ptr specialization
  template <>
  struct unexpected_type<exception_ptr>; 

  // \ref{unexpected.factories}, Unexpected factories
  template <class E>
  constexpr unexpected_type<decay_t<E>> make_unexpected(E&& v);
  unexpected_type<std::exception_ptr> make_unexpected_from_current_exception();
}}}
\end{lstlisting}

A program that necessitates the instantiation of template \cpp{unexpected} for a reference type or \cpp{void} is ill-formed.

\wordingSubSec{Unexpected object type}{unexpected.object}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% unexpected_type object type
\begin{lstlisting}
template <class E=std::exception_ptr>
class unexpected_type {
public:
    unexpected_type() = delete;
    constexpr explicit unexpected_type(E const&);   
    constexpr explicit unexpected_type(E&&);
    constexpr E const& value() const;                              
}; 
\end{lstlisting}

% unexpected_type constructor from underlying.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    constexpr explicit unexpected_type(E const&);   
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Build an unexpected by copying the parameter to the internal storage.
\end{wordingTextItem}
\end{wordingPara}

% unexpected_type move constructor from underlying.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    constexpr explicit unexpected_type(E &&);   
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Build an unexpected by moving the parameter to the internal storage.
\end{wordingTextItem}
\end{wordingPara}

% unexpected_type constructor from underlying.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    constexpr E const& value() const;                              
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
A const reference to the stored error.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Unexpected exception_ptr specialization}{unexpected.exception_ptr}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <>
class unexpected_type<std::exception_ptr> {
public:
    unexpected_type() = delete;
    explicit unexpected_type(std::exception_ptr const&);
    explicit unexpected_type(std::exception_ptr&&);
    template <class E>
      explicit unexpected_type(E);     
    std::exception_ptr const &value() const;                              
}; 
\end{lstlisting}
\noindent

% unexpected_type constructor from underlying.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    constexpr explicit unexpected_type(exception_ptr const&);   
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Build an unexpected by copying the parameter to the internal storage.
\end{wordingTextItem}
\end{wordingPara}

% unexpected_type move constructor from underlying.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    constexpr explicit unexpected_type(exception_ptr &&);   
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Build an unexpected by moving the parameter to the internal storage.
\end{wordingTextItem}
\end{wordingPara}

% unexpected_type constructor from an Exception.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    constexpr explicit unexpected_type(E e);   
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Build an unexpected storing the result of make_exception_ptr(e).
\end{wordingTextItem}
\end{wordingPara}

% unexpected_type constructor from underlying.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    constexpr exception_ptr const& value() const;                              
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
A const reference to the stored \cpp{exception_ptr}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Factories}{unexpected.factories}

% make_unexpected  factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class E>
constexpr unexpected_type<decay_t<E>> make_unexpected(E&& v);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{unexpected<decay_t<E>>(v)}.
\end{wordingTextItem}
\end{wordingPara}

% make_unexpected  factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr unexpected_type<std::exception_ptr> make_unexpected_from_current_exception();
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{unexpected<std::exception_ptr>(std::current_exception())}.
\end{wordingTextItem}
\end{wordingPara}

Insert a new section.

\wordingSec{Expected objects}{expected}
%%%%%%%%%%%%%%%%%%%%%

\wordingSubSec{In general}{expected.general}
%%%%%%%%%%%%%%%%%%%%%%%%

This subclause describes class template expected that represents expected objects. An expected object for object type T is an object that contains the storage for another object and manages the lifetime of this contained object T, alternatively it could contain the storage for another unexpected object E. The contained object may not be initialized after the expected object has been initialized, and may not be destroyed before the expected object has been destroyed. The initialization state of the contained object is tracked by the expected object.

\wordingSubSec{Header <experimental/expected> synopsis}{expected.synop}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
  // \ref{expected.holder}, holder class used as default.  
  class holder;
  // \ref{expected.object}, expected for object types  
  template <class E= exception_ptr, class T=holder>
  class expected;
  // \ref{expected.object.void}, Specialization for void.  
  template <class E>
  class expected<E, void>;
  // \ref{expected.object.meta}, Specialization of expected as a meta-function : T-> expected<E,T>.  
  template <class E>
  class expected<E, holder>;
   
  // \ref{expected.unexpect}, unexpect tag
  struct unexpect_t{};
  constexpr unexpet_t unexpect{};
   
  // \ref{expected.bad_expected_access}, class bad_expected_access
  class bad_expected_access;
  
  // \ref{expected.expected_default_constructed}, class expected_default_constructed
  class expected_default_constructed;
  
  // \ref{expected.relational_op}, Expected relational operators
  template <class T, class E>
    constexpr bool operator==(const expected<E,T>&, const expected<E,T>&);
  template <class T, class E>
    constexpr bool operator!=(const expected<E,T>&, const expected<E,T>&);
  template <class T, class E>
    constexpr bool operator<(const expected<E,T>&, const expected<E,T>&);
  template <class T, class E>
    constexpr bool operator>(const expected<E,T>&, const expected<E,T>&);
  template <class T, class E>
    constexpr bool operator<=(const expected<E,T>&, const expected<E,T>&);
  template <class T, class E>
    constexpr bool operator>=(const expected<E,T>&, const expected<E,T>&);
    
  // \ref{expected.comparison_T}, Comparison with T
  template <class T, class E> constexpr bool operator==(const expected<E,T>&, const T&);
  template <class T, class E> constexpr bool operator==(const T&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator!=(const expected<E,T>&, const T&);
  template <class T, class E> constexpr bool operator!=(const T&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator<(const expected<E,T>&, const T&);
  template <class T, class E> constexpr bool operator<(const T&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator<=(const expected<E,T>&, const T&);
  template <class T, class E> constexpr bool operator<=(const T&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator>(const expected<E,T>&, const T&);
  template <class T, class E> constexpr bool operator>(const T&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator>=(const expected<E,T>&, const T&);
  template <class T, class E> constexpr bool operator>=(const T&, const expected<E,T>&);

  // \ref{expected.comparison_unexpected_E}, Comparison with unexpected_type<E>
  template <class T, class E> constexpr bool operator==(const expected<E,T>&, const unexpected<E>&);
  template <class T, class E> constexpr bool operator==(const unexpected<E>&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator!=(const expected<E,T>&, const unexpected<E>&);
  template <class T, class E> constexpr bool operator!=(const unexpected<E>&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator<(const expected<E,T>&, const unexpected<E>&);
  template <class T, class E> constexpr bool operator<(const unexpected<E>&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator<=(const expected<E,T>&, const unexpected<E>&);
  template <class T, class E> constexpr bool operator<=(const unexpected<E>&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator>(const expected<E,T>&, const unexpected<E>&);
  template <class T, class E> constexpr bool operator>(const unexpected<E>&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator>=(const expected<E,T>&, const unexpected<E>&);
  template <class T, class E> constexpr bool operator>=(const unexpected<E>&, const expected<E,T>&);


  // \ref{expected.specalg}, Specialized algorithms
  template <class T> 
    void swap(expected<E,T>&, expected<E,T>&) noexcept(see below);

  // \ref{expected.factories}, Factories
  template <class T> constexpr expected<exception_ptr, decay_t<T>> make_expected(T&& v);
  template <> expected<exception_ptr, void> make_expected(); 
  template <class E> expected<E,void> make_expected(); 
  
  template <class T>
  expected_type<T> make_expected_from_current_exception();
  template <class T, class E>
   constexpr expected<exception_ptr,T> make_expected_from_exception(E e); 
  template <class T>
   constexpr expected<exception_ptr,T> make_expected_from_exception(std::exception_ptr v);   
 
  template <class T, class E>
   constexpr expected<decay_t<E>,T> make_expected_from_error(E v);

  template <class F>
   constexpr typename expected<exception_ptr, typename result_type<F>::type
   make_expected_from_call(F f);

  // \ref{expected.hash}, hash support
  template <class T> struct hash;
  template <class T> struct hash<expected<E,T>>;
}}}
\end{lstlisting}

A program that necessitates the instantiation of template \cpp{expected<E,T>} with \cpp{T} for a reference type\, or for possibly cv-qualified types \cpp{in_place_t}, \cpp{unexpect_t} or \cpp{unexpected_type<E>} is ill-formed.

\wordingSubSec{Definitions}{expected.defs}
%%%%%%%%%%%%%%%%%%%%%%

An instance of \cpp{expected<E,T>} is said to be valued if it contains an value of type \cpp{T}.
An instance of \cpp{expected<E,T>} is said to be unexpected if it contains an object of type \cpp{E}.

\wordingSubSec{expected for object types}{expected.object}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}

  template <class T, class E>
  class expected
  {
  public:
    typedef T value_type;
    typedef E error_type;
    
    template <class U>
    struct rebind {
      typedef expected<error_type, U> type;
    };
    
     // \ref{expected.object.ctor}, constructors
    constexpr expected() noexcept(see below);
    expected(const expected&);
    expected(expected&&) noexcept(see below);
    
    constexpr expected(const T&);
    constexpr expected(T&&);
    template <class... Args> 
      constexpr explicit expected(in_place_t, Args&&...);     
    template <class U, class... Args>
      constexpr explicit expected(in_place_t, initializer_list<U>, Args&&...);
      
    constexpr expected(unexpected_type<E> const&);
    template <class Err> 
    constexpr expected(unexpected_type<Err> const&);

    // \ref{expected.object.dtor}, destructor
    ~expected();

    // \ref{expected.object.assign}, assignment
    expected& operator=(const expected&);
    expected& operator=(expected&&) noexcept(see below);
    
    template <class U> expected& operator=(U&&);
    
    expected& operator=(const unexpected_type<E>&);
    expected& operator=(unexpected_type<E>&&) noexcept(see below);
    
    template <class... Args> void emplace(Args&&...);
    template <class U, class... Args>
      void emplace(initializer_list<U>, Args&&...);

    // \ref{expected.object.swap}, swap
    void swap(expected&) noexcept(see below);

    // \ref{expected.object.observe}, observers
    constexpr T const* operator ->() const;
    constexpr T* operator ->();
    
    constexpr T const& operator *() const&;
    constexpr T& operator *() &;
    constexpr T&& operator *() &&;
    
    constexpr explicit operator bool() const noexcept;
    
    constexpr T const& value() const&;
    constexpr T& value() &;
    constexpr T&& value() &&;
    
    constexpr E const& error() const&;
    constexpr E& error() &;
    constexpr E&& error() &&;
    
    constexpr unexpected<E>  get_unexpected() const;
    
    template <typename Ex>
    bool has_exception() const;
      
    template <class U> constexpr T value_or(U&&) const&;
    template <class U> T value_or(U&&) &&;
    
    template <class G> constexpr T value_or_throw() const&;
    template <class G> T value_or_throw() &&;

    // \ref{expected.object.factories}, factories

    template <typename Ex, typename F>
    expected<E,T> catch_exception(F&& f);

    template <typename F>
      auto next(F&& func) const -> expected<E, decltype(func(val))>;
    template <typename F>
      expected<E,T> recover(F&& f);
    template <typename F>
      auto then(F&& func) const -> expected<E, decltype(func(*this))>;
  
  private:
    bool has_value;    // exposition only
    union
    {
      value_type val;  // exposition only
      error_type err;  // exposition only
    };
  };

\end{lstlisting}


Valued instances of \cpp{expected<E,T>} where \cpp{T} and \cpp{E} is of object type shall contain a value of type \cpp{T} or a value of type \cpp{E} within its own storage. This value is referred to as the contained or the unexpected value of the expected object. Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained or unexpected value. The contained or unexpected value shall be allocated in a region of the \cpp{expected<E,T>} storage suitably aligned for the type \cpp{T} and \cpp{E}.
\newline

Members \cpp{has_value}, \cpp{val} and \cpp{err} are provided for exposition only. Implementations need not provide those members. \cpp{has_value} indicates whether the expected object's contained value has been initialized (and not yet destroyed); when \cpp{has_value} is true \cpp{val} points to the contained value, and when it is false \cpp{err} points to the erroneous value. 

\cpp{T} and \cpp{E} shall be an object type and shall satisfy the requirements of \cpp{Destructible}.

\wordingSubSubSec{Constructors}{expected.object.ctor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Default Constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr expected<E,T>::expected() noexcept(see below);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{T()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the default constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to:\\
\cpp{is_nothrow_default_constructible<T>::value}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
 \cpp{is_default_constructible<T>::value}.
\end{wordingTextItem}


\end{wordingPara}

% Copy Constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
expected<E,T>::expected(const expected<E,T>& rhs);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{bool(rhs)} initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{*rhs}.\\

\noindent
If \cpp{!bool(rhs)} initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{rhs.error()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T} or \cpp{E}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_copy_constructible<T>::value} and\\
\cpp{is_copy_constructible<E>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Move Constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
expected<E,T>::expected(expected<E,T> && rhs) noexcept(/*see below*/);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{bool(rhs)} initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{std::move(*rhs)}. \\

\noindent
If \cpp{!bool(rhs)} initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{std::move(rhs.error())}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)} and \\
\cpp{bool(rhs)} is unchanged.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T} or \cpp{E}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to:\\
\cpp{is_nothrow_move_constructible<T>::value == trye} and   \\
\cpp{is_nothrow_move_constructible<E>::value}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_move_constructible<T>::value} and \\
\cpp{is_move_constructible<E>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Value Constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr expected<E,T>::expected(const T& v);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{v}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{T}'s selected constructor is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_copy_constructible<T>::value}. 
\end{wordingTextItem}
\end{wordingPara}

% Move value constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr expected<E,T>::expected(T&& v); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{std::move(v)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{T}'s selected constructor is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_move_constructible<T>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Emplace constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class... Args>
constexpr explicit expected(in_place_t, Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the arguments \cpp{std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{T}'s constructor selected for the initialization is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_constructible<T, Args&&...>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Emplace constructor with initializer list.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class U, class... Args>
constexpr explicit expected(in_place_t, initializer_list<U> il, Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the arguments \cpp{il, std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless:\\
\noindent
\cpp{is_constructible<T, initializer_list<U>&, Args&&...>::value}.\\

\noindent
If \cpp{T}'s constructor selected for the initialization is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_constructible<T, initializer_list<U>&, Args&&...>::value}.
\end{wordingTextItem}
\end{wordingPara}


% Unexpected Constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr expected<E,T>::expected(unexpected_type<E> const& e);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the unexpected value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{e.value()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{! *this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{E}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{E}'s selected constructor is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_copy_constructible<E>::value}. 
\end{wordingTextItem}
\end{wordingPara}

% Unexpected move constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr expected<E,T>::expected(unexpected_type<E>&& e); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the unexpected value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{std::move(e.value())}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{! *this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{E}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{E}'s selected constructor is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_move_constructible<E>::value}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Destructor}{expected.object.dtor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Destructor.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
expected<E,T>::~expected();
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{is_trivially_destructible<T>::value != true} and \cpp{bool(*this)}, calls \cpp{val->T::~T()}.\\
If \cpp{is_trivially_destructible<E>::value != true} and \cpp{! *this}, calls \cpp{err->E::~E()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{is_trivially_destructible<T>::value} and \cpp{is_trivially_destructible<E>::value} then this destructor shall be a trivial destructor.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Assignment}{expected.object.assign}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Copy assignment operator.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
expected<E,T>& expected<E,T>::operator=(const expected<E,T>& rhs); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
if \cpp{bool(*this)} and \cpp{bool(rhs)}, assigns \cpp{*rhs} to the contained value \cpp{val}, otherwise \\
if \cpp{bool(*this)} and \cpp{! rhs}, destroys the contained value by calling \cpp{val->T::~T()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}, otherwise \\
if \cpp{! *this} and \cpp{! rhs}, assigns \cpp{rhs.error()} to the contained value \cpp{err}, otherwise \\
if \cpp{! *this} and \cpp{bool(rhs)}, destroys the contained value by calling \cpp{err->E::~E()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, the values of \cpp{bool(*this)} and \cpp{bool(rhs)} remain unchanged. If an exception is thrown during the call to \cpp{T}'s copy constructor, no effect. If an exception is thrown during the call to \cpp{T}'s copy assignment, the state of its contained value is as defined by the exception safety guarantee of \cpp{T}'s copy assignment. If an exception is thrown during the call to \cpp{E}'s copy constructor, no effect. If an exception is thrown during the call to \cpp{E}'s copy assignment, the state of its contained value is as defined by the exception safety guarantee of \cpp{E}'s copy assignment.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_copy_constructible<T>::value} and\\
\cpp{is_copy_assignable<T>::value} and\\
\cpp{is_copy_constructible<E>::value} and\\
\cpp{is_copy_assignable<E>::value}.
\end{wordingTextItem}

\end{wordingPara}

% Move assignment operator.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
expected<E,T>& expected<E,T>::operator=(expected<E,T>&& rhs) noexcept(/*see below*/); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
if \cpp{bool(*this)} and \cpp{rhs} is values, assigns \cpp{std::move(*rhs)} to the contained value \cpp{val}, otherwise \\
if \cpp{bool(*this)} and \cpp{! rhs}, destroys the contained value by calling \cpp{val->T::~T()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}, otherwise \\
if \cpp{! *this} and \cpp{! rhs}, assigns \cpp{std::move(rhs.error())} to the contained value \cpp{err}, otherwise  
if \cpp{! *this} and \cpp{bool(rhs)}, destroys the contained value by calling \cpp{err->E::~E()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to:\\
\cpp{is_nothrow_move_assignable<T>::value &&}\\
\cpp{is_nothrow_move_constructible<T>::value &&}\\
\cpp{is_nothrow_move_assignable<E>::value &&}\\
\cpp{is_nothrow_move_constructible<E>::value}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, the values of  \cpp{bool(*this)} and \cpp{bool(rhs)} remain unchanged. If an exception is thrown during the call to \cpp{T}'s move constructor, the state of \cpp{rhs.val} is determined by exception safety guarantee of \cpp{T}'s move constructor. If an exception is thrown during the call to \cpp{T}'s move assignment, the state of \cpp{val} and \cpp{rhs.val} is determined by exception safety guarantee of \cpp{T}'s move assignment. If an exception is thrown during the call to \cpp{E}'s move constructor, the state of \cpp{rhs.err} is determined by exception safety guarantee of \cpp{E}'s move constructor. If an exception is thrown during the call to \cpp{E}'s move assignment, the state of \cpp{err} and \cpp{rhs.err} is determined by exception safety guarantee of \cpp{E}'s move assignment.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_move_constructible<T>::value} and \\
\cpp{is_move_assignable<T>::value} and \\
\cpp{is_move_constructible<E>::value} and
\cpp{is_move_assignable<E>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Value assignment operator.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class U>
expected<E,T>& expected<E,T>::operator=(U&& v); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{bool(*this)} assigns \cpp{std::forward<U>(v)} to the contained value; otherwise destroys the contained value by calling \cpp{err->E::~E()} and initializes the unexpected value as if direct-non-list-initializing object of type \cpp{T} with \cpp{std::forward<U>(v)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, \cpp{bool(*this)} remains unchanged. If an exception is thrown during the call to \cpp{E}'s constructor, the state of \cpp{e} is determined by exception safety guarantee of \cpp{E}'s constructor. If an exception is thrown during the call to \cpp{E}'s assignment, the state of \cpp{err} and \cpp{e} is determined by exception safety guarantee of \cpp{E}'s assignment.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_constructible<T,U>::value} and \\
\cpp{is_assignable<T&, U>::value}.
\end{wordingTextItem}
\begin{wordingNoteItem}
The reason to provide such generic assignment and then constraining it so that effectively \cpp{T == U} is to guarantee that assignment of the form \cpp{o = \{\}} is unambiguous.
\end{wordingNoteItem}
\end{wordingPara}

% unexpected assignment operator.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
expected<E,T>& expected<E,T>::operator=(unexpected_type<E>&& e); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{! *this} assigns \cpp{std::forward<E>(e.value())} to the contained value; otherwise destroys the contained value by calling \cpp{val->T::~T()} and initializes the contained value as if direct-non-list-initializing object of type \cpp{E} with \cpp{std::forward<unexpected_type<E>>(e).value()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{! *this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, value of valued remains unchanged. If an exception is thrown during the call to \cpp{T}'s constructor, the state of \cpp{v} is determined by exception safety guarantee of \cpp{T}'s constructor. If an exception is thrown during the call to \cpp{T}'s assignment, the state of \cpp{val} and \cpp{v} is determined by exception safety guarantee of \cpp{T}'s assignment.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_copy_constructible<E>::value} and \\
\cpp{is_assignable<E&, E>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Emplace assignment.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class... Args>
void expected<E,T>::emplace(Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}if \cpp{bool(*this)}, assigns the contained value \cpp{val} as if constructing an object of type \cpp{T} with the arguments \cpp{std::forward<Args>(args)...}, otherwise destroys the contained value by calling \cpp{err->E::~E()} and  initializes the contained value as if constructing an object of type \cpp{T} with the arguments \cpp{std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If an exception is thrown during the call to \cpp{T}'s constructor, \cpp{*this} is disengaged, and the previous \cpp{val} (if any) has been destroyed.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_constructible<T, Args&&...>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Emplace with initializer list assignment.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class U, class... Args>
void expected<E,T>::emplace(initializer_list<U> il, Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
if \cpp{bool(*this)}, assigns the contained value \cpp{val} as if constructing an object of type \cpp{T} with the arguments \cpp{il,std::forward<Args>(args)...}, otherwise 
destroys the contained value by calling \cpp{err->E::~E()} and  initializes the contained value as if constructing an object of type \cpp{T} with the arguments \cpp{il,std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If an exception is thrown during the call to \cpp{T}'s constructor, \cpp{! *this} , and the previous \cpp{val} (if any) has been destroyed.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_constructible<T, initializer_list<U>&, Args&&...>::value}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Swap}{expected.object.swap}
%%%%%%%%%%%%%%%%%%%%%%%%%%

% swap operation.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
void expected<E,T>::swap(expected<E,T>& rhs) noexcept(/*see below*/); 
\end{lstlisting}
\begin{wordingPara}

\begin{wordingTextItem}{Effects}
if \cpp{bool(*this)} and \cpp{bool(rhs)}, calls \cpp{swap(val, rhs.val)}, otherwise \\
if \cpp{! *this} and \cpp{! rhs}, calls \cpp{swap(err, rhs.err)}, otherwise \\
if \cpp{bool(*this)} and \cpp{! rhs}, initializes a temporary variable e by direct-initialization with \cpp{std::move(rhs.err))}, initializes the contained value of \cpp{rhs} by direct-initialization with \cpp{std::move(*(*this))}, initializes the expected value of \cpp{*this} by direct-initialization with \cpp{std::move(rhs.err)} and swaps \cpp{has_value} and \cpp{rhs.has_value}, otherwise \\
calls to \cpp{rhs.swap(*this)};
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
\todo{This must be reworded.}
If any exception is thrown, values of \cpp{has_value} and \cpp{rhs.has_value} remain unchanged. If an exception is thrown during the call to function swap the state of \cpp{val} and \cpp{rhs.val} is determined by the exception safety guarantee of swap for lvalues of \cpp{T}. If an exception is thrown during the call to \cpp{T}'s move constructor, the state of \cpp{val} and \cpp{rhs.val} is determined by the exception safety guarantee of \cpp{T}'s move constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exceptions that the expressions in the Effects clause throw.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to: \\
\cpp{is_nothrow_move_constructible<T>::value && noexcept(swap(declval<T&>(), declval<T&>())) &&} \\
\cpp{is_nothrow_move_constructible<E>::value && noexcept(swap(declval<E&>(), declval<E&>()))}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
LValues of type \cpp{T} shall be swappable, \cpp{is_move_constructible<T>::value}, LValues of type \cpp{E} shall be swappable and \cpp{is_move_constructible<T>::value}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Observers}{expected.object.observe}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% -> operator.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr T const* expected<E,T>::operator->() const;
constexpr T* expected<E,T>::operator->(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{&val}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
Unless \cpp{T} is a user-defined type with overloaded unary operator\&, the first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% * operator.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr T const& expected<E,T>::operator *() const&;
constexpr T& expected<E,T>::operator *() &;
constexpr T&& expected<E,T>::operator *() &&;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{val}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% bool conversion operator.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr explicit expected<E,T>::operator bool() noexcept; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{has_value}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% value accessor.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr T const& expected<E,T>::value() const&;
constexpr T& expected<E,T>::value() &;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{val}, \cpp{if bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
\cpp{bad_expected_access(err)} if \cpp{!*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% value accessor.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr T&& expected<E,T>::value() &&;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{move(val)}, \cpp{if bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
\cpp{bad_expected_access(err)} if \cpp{!*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% error accessor.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr E const& expected<E,T>::error() const&;
constexpr E& expected<E,T>::error() &; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{!*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{err}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% error accessor.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr E&& expected<E,T>::error() &&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{!*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{move(err)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% has_exception accessor.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class Ex>
bool expected<E,T>::has_exception() const;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{true} if and only if \cpp{!(*this)} and the stored exception is a base type of \cpp{Ex}.
\end{wordingTextItem}
\end{wordingPara}


% unexpected conversion.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr unexpected<E> expected<E,T>::get_unexpected() const;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{!*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{make_unexpected(err)}.
\end{wordingTextItem}
\end{wordingPara}

% value_or method.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class U>
constexpr T expected<E,T>::value_or(U&& v) const&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{bool(*this) ? **this : static_cast<T>(std::forward<U>(v))}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If \cpp{has_value} and exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{has_value} and \cpp{v} remains unchanged and the state of \cpp{val} is determined by the exception safety guarantee of the selected constructor of \cpp{T}. Otherwise, when exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{*this} remains unchanged and the state of \cpp{v} is determined by the exception safety guarantee of the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If both constructors of \cpp{T} which could be selected are \cpp{constexpr} constructors, this function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_copy_constructible<T>::value} and \\
\cpp{is_convertible<U&&, T>::value}.
\end{wordingTextItem}
\end{wordingPara}

% move value_or.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class U>
T expected<E,T>::value_or(U&& v) &&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{bool(*this) ? std::move(**this) : static_cast<T>(std::forward<U>(v))}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If \cpp{has_value} and exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{has_value} and \cpp{v} remains unchanged and the state of \cpp{val} is determined by the exception safety guarantee of the \cpp{T}'s constructor. Otherwise, when exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{*this} remains unchanged and the state of \cpp{v} is determined by the exception safety guarantee of the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_move_constructible<T>::value} and \\
\cpp{is_convertible<U&&, T>::value}.
\end{wordingTextItem}
\end{wordingPara}

% value_or_throw method.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class G>
constexpr T expected<E,T>::value_or_throw() const&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
If \cpp{bool(*this)} then \cpp{**this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If \cpp{has_value} and exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{has_value} remains unchanged and the state of \cpp{val} is determined by the exception safety guarantee of the selected constructor of \cpp{T}. Otherwise, when exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{*this} remains unchanged.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
If \cpp{! *this} then \cpp{G(error())}.

\noindent
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If both constructors of \cpp{T} which could be selected are \cpp{constexpr} constructors, this function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_copy_constructible<T>::value} and \\
\cpp{is_convertible<U&&, T>::value}.
\end{wordingTextItem}
\end{wordingPara}

% move value_or_throw.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class G>
T expected<E,T>::value_or_throw() &&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
If \cpp{bool(*this)} then \cpp{std::move(**this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If \cpp{has_value} and exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{has_value} remains unchanged and the state of \cpp{val} is determined by the exception safety guarantee of the \cpp{T}'s constructor. Otherwise, when exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{*this} remains unchanged.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
If \cpp{! *this} then \cpp{G(error())}.

\noindent
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_move_constructible<T>::value} and \\
\cpp{is_convertible<U&&, T>::value}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Factories}{expected.object.factories}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% catch_exception factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class Ex,class F>
expected<E,T> expected<E,T>::catch_exception(F&& func) const;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
if \cpp{has_exception<Ex>()} call the continuation function \cpp{fuct} with the stored exception as parameter.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
if \cpp{has_exception<Ex>()} returns the result of the call continuation function \cpp{fuct} possibly wrapped on a \cpp{expected<E,T>}, 
otherwise, returns \cpp{*this}.
\end{wordingTextItem}
\end{wordingPara}

% then factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class Ex,class F>
auto expected<E,T>::then(F&& func) const -> unwrap_nested_expected_t<expected<E, decltype(func(val))>>;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
returns \cpp{unwrap(expected<E, decltype(func(val))>(funct(*this)))}, 
\end{wordingTextItem}
\end{wordingPara}

% next factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class Ex,class F>
auto expected<E,T>::next(F&& func) const -> unwrap_nested_expected_t<expected<E, decltype(func(val))>>;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
if \cpp{bool(*this)} returns \cpp{unwrap(expected<E, decltype(func(val))>(funct(**this)))}, 
otherwise, returns \cpp{get_unexpected()}.
\end{wordingTextItem}
\end{wordingPara}

% recover factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class Ex,class F>
expected<E,T> expected<E,T>::recover(F&& func) const;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
if \cpp{! (*this)} returns \cpp{unwrap(expected<E, decltype(func(val))>(funct(**this)))}, 
if \cpp{! *this} returns the result of the call continuation function \cpp{fuct} possibly wrapped on a \cpp{expected<E,T>}, 
otherwise, returns \cpp{*this}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{\cpp{expected} as a meta-fuction}{expected.object.meta}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
  template <class E>
  class expected<E, holder>
  public:
    template <class T>
    using type = expected<E,T>
  };
\end{lstlisting}

\wordingSubSec{expected for void}{expected.object.void}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
  template <class E>
  class expected<E, void>
  {
  public:
    typedef void value_type;
    typedef E error_type;
    
    template <class U>
    struct rebind {
      typedef expected<error_type, U> type;
    };
    
     // \ref{expected.object.void.ctor}, constructors
    constexpr expected() noexcept;
    expected(const expected&);
    expected(expected&&) noexcept(see below);
    constexpr explicit expected(in_place_t);     
      
    constexpr expected(unexpected_type<E> const&);
    template <class Err> 
    constexpr expected(unexpected_type<Err> const&);

    // \ref{expected.object.void.dtor}, destructor
    ~expected();

    // \ref{expected.object.void.assign}, assignment
    expected& operator=(const expected&);
    expected& operator=(expected&&) noexcept(see below);
    void emplace();

    // \ref{expected.object.void.swap}, swap
    void swap(expected&) noexcept(see below);

    // \ref{expected.object.void.observe}, observers
    constexpr explicit operator bool() const noexcept;
    void value() const;
    constexpr E const& error() const&;
    constexpr E& error() &;
    constexpr E&& error() &&;
    constexpr unexpected<E>  get_unexpected() const;
    
    template <typename Ex>
    bool has_exception() const;
    // \ref{expected.object.void.factories}, factories

    template <typename Ex, typename F>
    expected<E,void> catch_exception(F&& f);

    template <typename F>
      auto next(F&& func) const -> expected<E, decltype(func())>;
    template <typename F>
      expected<void,E> recover(F&& f);
    template <typename F>
      auto then(F&& func) const -> expected<E, decltype(func(*this))>;

  private:
    bool has_value;    // exposition only
    union
    {
      unsigned char dummy;  // exposition only
      error_type err;  // exposition only
    };
  };

\end{lstlisting}

\todo{Describe the functions.}



\wordingSubSec{unexpect tag}{expected.unexpect}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% unexpect tag
\begin{lstlisting}
struct unexpet_t{};
constexpr unexpet_t unexpet{};
\end{lstlisting}
\noindent


\wordingSubSec{Template Class bad_expected_access}{expected.bad_expected_access}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
namespace std {
  template <class E>
  class bad_expected_access : public logic_error {
  public:
    explicit bad_expected_access(E);
    constexpr error_type const& error() const;
    error_type& error();
  };
}
\end{lstlisting}

The template class \cpp{bad_expected_access} defines the type of objects thrown as exceptions to report the situation where an attempt is made to access the value of a unexpected expected object.

% constructor with string message.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
bad_expected_access::bad_expected_access(E e); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Constructs an object of class \cpp{bad_expected_access} storing the parameter.
\end{wordingTextItem}
\end{wordingPara}

% error accessor.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr E const& bad_expected_access::error() const; 
E& bad_expected_access::error(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
The stored error..
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Class expected_default_constructed}{expected.expected_default_constructed}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
namespace std {
  template <class E>
  class expected_default_constructed : public logic_error {
  public:
    explicit expected_default_constructed();
  };
}
\end{lstlisting}

The class \cpp{expected_default_constructed} defines the type of objects thrown as exceptions to report the situation where an attempt is made to access the \cpp{expected<exception_ptr,T>::error()}/\cpp{expected<exception_ptr,T>::get_unexpected()} value of a unexpected expected object that has no exception stored.

\todo{Describe the functions.}

\wordingSubSec{Expected Relational operators}{expected.relational_op}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{Describe the functions.}

\wordingSubSec{Comparison with \cpp{T}}{expected.comparison_T}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{Describe the functions.}

\wordingSubSec{Comparison with \cpp{unexpected<E>}}{expected.comparison_unexpected_E}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{Describe the functions.}

\wordingSubSec{Specialized algorithms}{expected.specalg}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% swap free function.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class T, class E>
void swap(expected<E,T>& x, expected<E,T>& y) noexcept(noexcept(x.swap(y))); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
calls \cpp{x.swap(y)}.
\end{wordingTextItem}
\end{wordingPara}


\wordingSubSec{Expected Factories}{expected.factories}

% make_expected move value factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class T>
constexpr expected<exception_ptr, typename decay<T>::type> make_expected(T&& v);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<exception_ptr, typename decay<T>::type>(std::forward<T>(v))}.
\end{wordingTextItem}
\end{wordingPara}

% make_expected factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
expected<exception_ptr, void> make_expected(); 
template <class E>
expected<E, void> make_expected(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<E,void>(in_place)}.
\end{wordingTextItem}
\end{wordingPara}

% make_expected_from_error factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class T>
expected<exception_ptr,T> make_expected_from_exception(std::exception_ptr v); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<exception_ptr,T>(unexpected_type<E>(std::forward<E>(v)))}.
\end{wordingTextItem}
\end{wordingPara}

% make_expected_from_error factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class T, class E>
constexpr expected<decay_t<E>,T> make_expected_from_error(E e);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<decay_t<E>,T>(make_unexpected(e));}
\end{wordingTextItem}
\end{wordingPara}


% make_expected_from_error factory (flying exception).
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class T>
constexpr expected<exception_ptr,T> make_expected_from_current_exception(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<exception_ptr,T>(make_unexpected_from_current_exception())}
\end{wordingTextItem}
\end{wordingPara}

% make_expected_from_call
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class F>
constexpr typename expected<exception_ptr, result_of<F()>::type make_expected_from_call(F funct);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Equivalent to}
\begin{lstlisting}[language=C++][xleftmargin=0pt]
  try
  {
    return make_expected(funct());
  }
  catch (...)
  {
    return make_unexpected_from_current_exception();
  }
\end{lstlisting}
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Hash support}{expected.hash}

\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class T, class E>
struct hash<expected<E,T>>; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\todo{This must be reworded}

The template specilaization \cpp{hash<T>} and \cpp{hash<E>} shall meet the requirements of class template \cpp{hash} (Z.X.Y). The template specialization \cpp{hash<expected<E,T>>} shall meet the requirements of class template \cpp{hash}. For an object \cpp{o} of type \cpp{expected<E,T>}, \cpp{if bool(o)}, \cpp{hash<expected<E,T>>()(o)} shall evaluate to the same value as \cpp{hash<T, E>()(*o);} otherwise it evaluates to an unspecified value.
\end{wordingTextItem}
\end{wordingPara}

\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class E>
struct hash<expected<E, void>>;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\end{wordingTextItem}
\end{wordingPara}

\section{Implementability}
This proposal can be implemented as pure library extension, without any compiler magic support, in C++14. An almost full reference implementation of this proposal can be found at TBoost.Expected \cite{boost.expected}. 
\section{Acknowledgement}

We are very grateful to Andrei Alexandrescu for his talk, which was the origin of this work.
We thanks also to every one that has contributed to the Haskell either monad, as either's interface was a source of inspiration.
Thanks to Fernando Cacciola, Andrzej Krzemieski and every one that has contributed to the wording and the rationalle of N3793 \cite{OptionalRev5}.

Vicente thanks personnaly Evgeny Panasyuk and Johannes Kapfhammer for their remarks on the operator \cpp{expect}. 

\newpage
\bibliographystyle{plain}
\bibliography{references}

\end{document}